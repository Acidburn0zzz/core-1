---
write: false
---

class window.GuideGuideCore
  constructor: (@panel) ->
    @panel.on 'click', '.js-tabbed-page-tab', @onTabClick
    @panel.on 'click', '.js-custom-form .js-make-grid', @onMakeGridFromCusom
    @panel.on 'click', '.js-sets-form .js-make-grid', @onMakeGridFromSet
    @panel.on 'click', '.js-sets-form .js-set-select', @onSelectSet
    @panel.on 'click', '.js-sets-form .js-delete-set', @onDeleteSet
    @panel.on 'click', '.js-grid-form .js-new-set', @onShowGridNewSetForm
    @panel.on 'click', '.js-custom-form .js-new-set', @onShowCustomNewSetForm
    @panel.on 'click', '.js-sets-form .js-new-set', @onShowCustomNewSetForm
    @panel.on 'click', '.js-cancel-set', @onHideNewSetForm
    @panel.on 'click', '.js-grid-form .js-save-set', @onSaveSetFromGrid
    @panel.on 'click', '.js-custom-form .js-save-set', @onSaveSetFromCustom
    @panel.on 'click', '.js-sets-form .js-edit-set', @onEditSet
    @panel.on 'guideguide:exitcustom', @onExitCustomForm
    @panel.on 'focus', '.js-custom-form .js-custom-input', @onFocusCustomForm
    @panel.on 'blur', '.js-custom-form .js-custom-input', @onBlurCustomForm

    @i18n or= 'en-us'
    @messages = new Messages(@i18n)
    @guideguideData = @getGuideGuideData()

    if @guideguideData
      @refreshSets()
    else
      @bootstrap()

  # Set default data the first time GuideGuide run.
  #
  # Returns nothing.
  bootstrap: =>
    console.log 'Bootstrapping GuideGuide'
    @guideguideData =
      panel: # Info about this install of GuideGuide
        newSetId: 3
      sets: [ # User sets
          id: 0
          name:'Outline'
          string: """
          | ~ | (hFl)
          | ~ | (vFl)
          """
        ,
          id: 1
          name:'Two column grid'
          string: """
          | ~ | ~ | (hFl)
          """
        ,
          id: 2
          name:'Three column grid'
          string: """
          | ~ | ~ | ~ | (hFl)
          """
      ]
      settings: # User settings
        horizontalRemainder: 'last'
        verticalRemainder:   'last'
        calculation:         'pixel'

    @saveGuideGuideData(@guideguideData)
    @refreshSets()

  # Update the panel's color theme  
  #
  #   theme - (String) name of the theme to be used
  #
  # Returns nothing.
  updateTheme: (theme) =>
    @panel.attr 'data-theme', theme

  # Behavior for navigating a collection of "pages" via a set of tabs
  #
  # Returns nothing.
  onTabClick: (event) =>
    event.preventDefault()

    exitPage   = @panel.find('.js-tabbed-page-tab.is-selected').attr 'data-page'
    enterPage  = $(event.currentTarget).attr 'data-page'

    return if enterPage == exitPage

    $('#guideguide').trigger "guideguide:exit#{ exitPage }"

    if filter = enterPage
      @selectTab @panel, filter

    $('#guideguide').trigger "guideguide:enter#{ enterPage }"

  # Select the tab that has the given tab-filter. If there is none, select the first tab.
  #
  # $container - (jQuery object) .js-tabbed-pages element
  # name       - (String) content of the data-page attribute. this item will be selected
  #
  # Returns nothing.
  selectTab: ($container, name) =>
    $container.find("[data-page]").removeClass 'is-selected'

    if name
      filter = -> $(this).attr('data-page') is name
      tab = $container.find('.js-tabbed-page-tab').filter filter
      tabBucket = $container.find('.js-tabbed-page').filter filter
    else
      tab = $container.find '.js-tabbed-page-tab:first'
      tabBucket = $container.find '.js-tabbed-page:first'

    # Select tab and bucket
    tab.addClass 'is-selected'
    tabBucket.addClass 'is-selected'

  # Get GuideGuide's data, including usage data, user preferences, and sets
  #
  # Returns an Object or null if no data exists.
  getGuideGuideData: (data = null) =>
    if data
      console.log "Retrieved data:", data
      return data
    else
      console.log "Failed to retrieve data"

  # Save GuideGuide's data, including usage data, user preferences, and sets
  #
  # Returns nothing.
  saveGuideGuideData: (data) =>
    console.log if data then "Saved data" else "Failed to retrieve data"

  onClickClearGuides: (event) =>
    event.preventDefault()
    @clearGuides()

  # Removes all guides from the document
  #
  # Returns nothing.
  clearGuides: =>
    console.log "Clear guides"

  # Add a collection of guides to the document.
  #
  #   guides - (Object) Collection of guides to be added.
  #
  # Returns nothing
  addGuides: (guides) =>
    console.log 'Adding guides:', guides

  # Clear any error reporting text and reset the field's validation
  #
  # Returns nothing.
  onFocusCustomForm: (event) =>
    $input = $(event.currentTarget)
    $input.attr 'data-valid', true
    $input.val $input.val().replace(/[\{\}]|\[.*?\]|^#.*?$/gm, '').replace(/\s+$/g,'')

  onBlurCustomForm: (event) =>
    $input = $(event.currentTarget)
    if string = $input.val().replace /^\s+|\s+$/g, ''
      ggsn = new GGSN $input.val()
      $input.attr 'data-valid', ggsn.isValid
      $input.val ggsn.toString()

  # Select a set in the sets list when it is clicked
  #
  # Returns nothing.
  onSelectSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget)
    $set.closest('.js-sets-form').find('.is-selected').removeClass('is-selected')
    $set.closest('.js-set').addClass('is-selected')

  onDeleteSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget).closest '.js-set'
    id = $set.attr 'data-id'

    @guideguideData.sets = $.grep @guideguideData.sets, (set) -> parseInt(set.id) != parseInt(id)

    @saveGuideGuideData(@guideguideData)
    @refreshSets()

  # When exiting the Custom form, clear it.
  #
  # Returns nothing
  onExitCustomForm: =>
    @panel.find('.js-ggsn-input').val('') if @panel.hasClass('is-showing-new-set-form')
    @hideNewSetForm()

  # Open Custom form with data from the set to be edited
  #
  # Returns nothing.
  onEditSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget).closest('.js-set')
    id = $set.attr('data-id')
    
    set = $.grep @guideguideData.sets, (set) -> parseInt(set.id) == parseInt(id)

    $form = @panel.find('.js-custom-form')
    $form.find('.js-set-name').val(set[0].name)
    $form.find('.js-custom-input').val(set[0].string)
    $form.find('.js-set-id').val(set[0].id)

    $('#guideguide').find('.js-custom-tab').click()
    @showCustomSetForm()

  # Fire save set event and pass it the contents of the custom form
  #
  # Returns nothing.
  onSaveSetFromCustom: (event) =>
    event.preventDefault()
    $form      = @panel.find('.js-custom-form')
    string     = $('.js-custom-input').val().replace /^\s+|\s+$/g, ''
    executable = $form.find('[data-valid="false"]').length == 0 and string.length > 0
    
    if executable
      obj =
        id: $form.find('.js-set-id').val()
        name: $form.find('.js-set-name').val()
        ggsn: string

      if !$('#guideguide').find('.js-set-id').val()
        @createNewSet(obj)
      else
        @updateSet(obj)

      @panel.find('.js-sets-tab').click()

  # Fire save set event and pass it the contents of the grid form
  #
  # Returns nothing.
  onSaveSetFromGrid: (event) =>
    event.preventDefault()
    $form      = @panel.find('.js-grid-form')
    data       = getFormData $form
    string     = stringifyFormData data
    executable = $form.find('[data-valid="false"]').length == 0 and string

    if executable
      console.group 'New set from form'
      console.log string
      console.groupEnd()
      obj =
        name: data.name
        ggsn: string

      @createNewSet(obj)
      @panel.find('.js-sets-tab').click()

  # Create a grid from the Custom form
  #
  # Returns nothing.
  onMakeGridFromCusom: (event) =>
    event.preventDefault()
    $form  = @panel.find('.js-custom-form')
    string = @panel.find('.js-custom-input').val().replace(/^\s+|\s+$/g, '')
    
    return unless $form.find('[data-valid="false"]').length == 0 and string and @getDocumentInfo()

    console.log 'Custom Grid'
    console.log string
    @addGuides @getGuides new GGSN string

  # Create a grid from a set
  #
  # Returns nothing.
  onMakeGridFromSet: (event) =>
    event.preventDefault()
    $set = $('.js-set-list').find('.is-selected').first()
    
    return unless $set.length and @getDocumentInfo()

    console.log 'Grid from set'
    data = $.grep @guideguideData.sets, (set) -> parseInt(set.id) == parseInt($set.attr 'data-id')
    console.log data
    @addGuides @getGuides new GGSN data[0].string

  createNewSet: (data) =>
    newSet =
      id: @guideguideData.panel.newSetId
      name: data.name
      string: data.ggn

    @guideguideData.panel.newSetId++
    @guideguideData.sets.push newSet
    @saveGuideGuideData(@guideguideData)
    @refreshSets()

  updateSet: (data) =>
    set = $.grep appAdapter.data.sets, (set) -> parseInt(set.id) == parseInt(data.id)

    set[0].name = data.name
    set[0].string = data.ggsn

    @saveGuideGuideData(@guideguideData)
    @refreshSets()

  # Remove any sets in the markup and update the list with a new set items for
  # each set in the list.
  #
  # Returns nothing.
  refreshSets: =>
    console.log 'Refreshing sets'
    $list = @panel.find('.js-set-list')
    $list.find('.js-set').remove()
    $.each @guideguideData.sets, (index,set) =>
      item = $('.js-set-item-template').clone(true).removeClass('js-set-item-template').css('display','')
      item.find('.js-set-item-name').html set.name
      item.attr 'data-id', set.id
      $list.append item

  # Handle clicks on the new set button
  #
  # Returns nothing
  onShowCustomNewSetForm: (event) =>
    event.preventDefault()
    @showCustomSetForm()

  # On the Grid page, display and focus new set name field, swap in save set
  # and cancel set buttons, hide make grid and new set buttons.
  #
  # Returns nothing.
  showCustomSetForm: =>
    @panel.find('.js-custom-tab').click() if @panel.find('.js-sets-tab.is-selected').length
    @panel.addClass('is-showing-new-set-form')
    @panel.find('.js-custom-form').find('.js-set-name').focus()

  # On the Custom page, display and focus new set name field, swap in save set
  # and cancel set buttons, hide make grid and new set buttons.
  #
  # Returns nothing.
  onShowGridNewSetForm: (event) =>
    event.preventDefault()
    @panel.addClass('is-showing-new-set-form')
    @panel.find('.js-grid-form').find('.js-set-name').focus() 

  # On both forms, Hide new set name, swap out save set and cancel set buttons, show make
  # grid and new set buttons
  #
  # Returns nothing.
  onHideNewSetForm: (event) =>
    event.preventDefault()
    @hideNewSetForm()

  hideNewSetForm: =>
    @panel.find('.js-grid-form').find('.js-set-name').val('')
    @panel.find('.js-grid-form').find('.js-set-id').val('')
    @panel.removeClass('is-showing-new-set-form')

  # Get information about the current active document.
  #
  #   info - (Object) info about the active document
  #
  # Example data:
  #
  #     info =
  #       width:   100
  #       height:  100
  #       ruler:   'pixels'
  #       offsetX: 0
  #       offsety: 0
  #
  # Returns an Object or null if no object exists.
  getDocumentInfo: (info = null) =>
    return if info then info else null

  # Turn a GuideGuide object into a collection of guides.
  #
  # ggn - GuideGuide Object to pull guides from
  #
  # Returns a collection of guides
  getGuides: (ggn) =>
    info = @getDocumentInfo()
    guides = []

    $.each ggn.grids, (index,grid) =>
      positionOffset   = 0
      gridOrientation  = grid.options.orientation.value
      guideOrientation = if gridOrientation == 'horizontal' then 'vertical' else 'horizontal'
      wholePixels      = grid.options.calculation && grid.options.calculation.value == 'pixel'
      fill             = grid.gaps.fill if grid.gaps.fill
      measuredWidth    = if gridOrientation == 'horizontal' then info.width else info.height
      measuredWidth    = grid.options.width.value if grid.options.width
      offset           = if gridOrientation == 'horizontal' then info.offsetX else info.offsetY

      # Calculate and set the value percent gaps. This calculation is based on
      # the document or selection width, less the margin area if it is greater
      # zero.
      if grid.gaps.percents
        $.each grid.gaps.percents, (index,gap) =>
          percentValue = measuredWidth*(gap.value/100)
          Math.floor percentValue if wholePixels
          gap.convertPercent percentValue

      # Subtract arbitrary gap value from non-margin area to get wildcard area,
      # which is used to calculate the size of the wildcards
      arbitrarySum = if grid.gaps.arbitrary then sum grid.gaps.arbitrary, 'value' else 0
      wildcardArea = measuredWidth - arbitrarySum

      if wildcardArea and fill
        # The grid contains a fill, figure out how many times it will fit and generate
        # new gaps for it.
        fillIterations = Math.floor wildcardArea/fill.sum(ggn.variables)
        fillCollection = []
        fillWidth = 0

        for i in [1..fillIterations]
          if fill.isVariable
            fillCollection = fillCollection.concat ggn.variables[fill.id]
            fillWidth += sum ggn.variables[fill.id], 'value'
          else
            newGap = fill.clone()
            newGap.isFill = false
            fillCollection.push newGap
            fillWidth += newGap.value

        wildcardArea -= fillWidth

      if wildcardArea and grid.gaps.wildcards
        # If the grid contains wildcards, figure out and set how wide they are
        wildcardWidth = wildcardArea/grid.gaps.wildcards.length

        if wholePixels
          wildcardWidth = Math.floor wildcardWidth
          remainderPixels = wildcardArea % grid.gaps.wildcards.length

        $.each grid.gaps.wildcards, (index,gap) =>
          gap.value = wildcardWidth

      if remainderPixels
        # If this is a pixel specific grid, whole pixel math usually results in remainder pixels.
        # This decides where amongst the wildcards the remainders should be distributed.
        remainderOffset = 0

        remainderOffset = Math.floor (grid.gaps.wildcards.length - remainderPixels)/2 if grid.options.remainder.value == 'center'
        remainderOffset = grid.gaps.wildcards.length - remainderPixels if grid.options.remainder.value == 'last'

        $.each grid.gaps.wildcards, (index, gap) =>
          gap.value++ if index >= remainderOffset && index < remainderOffset + remainderPixels

      # Figure out where the grid starts
      insertMarker = offset
      if grid.options.width && grid.options.position.value == 'last'
        areaWidth = if gridOrientation == 'horizontal' then info.width else info.height
        insertMarker += areaWidth - grid.options.width.value

      if grid.options.offset
        if grid.options.position.value == 'first'
          insertMarker += grid.options.offset.value
        else if grid.options.position.value == 'last'
          insertMarker -= grid.options.offset.value

      # Expand any fills
      $.each grid.gaps.all, (index,item) =>
        grid.gaps.all = grid.gaps.all.slice(0, index).concat fillCollection, grid.gaps.all.slice(index + 1) if item.isFill

      # Add all the guides
      $.each grid.gaps.all, (index,item) =>
        if item == '|'
          guides.push obj =
            location: insertMarker
            orientation: guideOrientation
        else
          insertMarker += item.value

    # Sort out duplicates
    uniqueGuides =
      horizontal: {}
      vertical: {}

    guides = $.grep guides, (el) =>
      unique = !uniqueGuides[el.orientation][el.location]
      uniqueGuides[el.orientation][el.location] = true
      unique

    guides

# Calculate the sum of an array of values
#
#   array - array to be added together
#   key   - optional key value to be used if array contains objects
#
# Returns a Number
sum = (array, key = null) ->
  total = 0
  $.each array, (index,value) =>
    if key
      total += array[index][key] if array[index][key]
    else
      total += array[index]
  total

