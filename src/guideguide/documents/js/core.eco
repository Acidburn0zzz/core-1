---
write: false
---

class window.GuideGuideCore
  constructor: (@panel) ->
    @panel.on 'click', '.js-tabbed-page-tab', @onTabClick
    @panel.on 'click', '.js-sets-form .js-make-grid', @onMakeGridFromSet
    @panel.on 'click', '.js-sets-form .js-set-select', @onSelectSet
    @panel.on 'click', '.js-sets-form .js-delete-set', @onDeleteSet

    @i18n or= 'en-us'
    @messages = new Messages(@i18n)
    @guideguideData = @getGuideGuideData()

    if @guideguideData
      @refreshSets()
    else
      @bootstrap()

  # Set default data the first time GuideGuide run.
  #
  # Returns nothing.
  bootstrap: =>
    console.log 'Bootstrapping GuideGuide'
    @guideguideData =
      panel: # Info about this install of GuideGuide
        newSetId: 3
      sets: [ # User sets
          id: 0
          name:'Outline'
          string: """
          | ~ | (hFl)
          | ~ | (vFl)
          """
        ,
          id: 1
          name:'Two column grid'
          string: """
          | ~ | ~ | (hFl)
          """
        ,
          id: 2
          name:'Three column grid'
          string: """
          | ~ | ~ | ~ | (hFl)
          """
      ]
      settings: # User settings
        horizontalRemainder: 'last'
        verticalRemainder:   'last'
        calculation:         'pixel'

    @saveGuideGuideData(@guideguideData)
    @refreshSets()

  # Update the panel's color theme  
  #
  #   theme - (String) name of the theme to be used
  #
  # Returns nothing.
  updateTheme: (theme) =>
    @panel.attr 'data-theme', theme

  # Behavior for navigating a collection of "pages" via a set of tabs
  #
  # Returns nothing.
  onTabClick: (event) =>
    event.preventDefault()

    exitPage   = @panel.find('.js-tabbed-page-tab.is-selected').attr 'data-page'
    enterPage  = $(event.currentTarget).attr 'data-page'

    return if enterPage == exitPage

    $('#guideguide').trigger "guideguideInternal:exit#{ exitPage }"

    if filter = enterPage
      @selectTab @panel, filter

    $('#guideguide').trigger "guideguideInternal:enter#{ enterPage }"

  # Select the tab that has the given tab-filter. If there is none, select the first tab.
  #
  # $container - (jQuery object) .js-tabbed-pages element
  # name       - (String) content of the data-page attribute. this item will be selected
  #
  # Returns nothing.
  selectTab: ($container, name) =>
    $container.find("[data-page]").removeClass 'is-selected'

    if name
      filter = -> $(this).attr('data-page') is name
      tab = $container.find('.js-tabbed-page-tab').filter filter
      tabBucket = $container.find('.js-tabbed-page').filter filter
    else
      tab = $container.find '.js-tabbed-page-tab:first'
      tabBucket = $container.find '.js-tabbed-page:first'

    # Select tab and bucket
    tab.addClass 'is-selected'
    tabBucket.addClass 'is-selected'

  # Get GuideGuide's data, including usage data, user preferences, and sets
  #
  # Returns an Object or null if no data exists.
  getGuideGuideData: (data = null) =>
    if data
      console.log "Retrieved data:", data
      return data
    else
      console.log "Failed to retrieve data"

  # Save GuideGuide's data, including usage data, user preferences, and sets
  #
  # Returns nothing.
  saveGuideGuideData: (data) =>
    console.log if data then "Saved data" else "Failed to retrieve data"

  # Removes all guides from the document
  #
  # Returns nothing.
  clearGuides: =>
    console.log "Clear guides"

  # Add a collection of guides to the document.
  #
  #   guides - (Object) Collection of guides to be added.
  #
  # Returns nothing
  addGuides: (guides) =>
    console.log 'Adding guides:', guides

  # Select a set in the sets list when it is clicked
  #
  # Returns nothing.
  onSelectSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget)
    $set.closest('.js-sets-form').find('.is-selected').removeClass('is-selected')
    $set.closest('.js-set').addClass('is-selected')

  onDeleteSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget).closest '.js-set'
    id = $set.attr 'data-id'

    @guideguideData.sets = $.grep @guideguideData.sets, (set) -> parseInt(set.id) != parseInt(id)

    @saveGuideGuideData(@guideguideData)
    @refreshSets()

  # Create a grid from a set
  #
  # Returns nothing.
  onMakeGridFromSet: (event) =>
    event.preventDefault()
    $set = $('.js-set-list').find('.is-selected').first()
    
    return unless $set.length and @getDocumentInfo()

    console.log 'Grid from set'
    data = $.grep @guideguideData.sets, (set) -> parseInt(set.id) == parseInt($set.attr 'data-id')
    console.log data
    @addGuides @getGuides new GGSN data[0].string

  # Remove any sets in the markup and update the list with a new set items for
  # each set in the list.
  #
  # Returns nothing.
  refreshSets: =>
    console.log 'Refreshing sets'
    $list = @panel.find('.js-set-list')
    $list.find('.js-set').remove()
    $.each @guideguideData.sets, (index,set) =>
      item = $('.js-set-item-template').clone(true).removeClass('js-set-item-template').css('display','')
      item.find('.js-set-item-name').html set.name
      item.attr 'data-id', set.id
      $list.append item

  # Get information about the current active document.
  #
  #   info - (Object) info about the active document
  #
  # Example data:
  #
  #     info =
  #       width:   100
  #       height:  100
  #       ruler:   'pixels'
  #       offsetX: 0
  #       offsety: 0
  #
  # Returns an Object or null if no object exists.
  getDocumentInfo: (info = null) =>
    return if info then info else null

  # Turn a GuideGuide object into a collection of guides.
  #
  # ggn - GuideGuide Object to pull guides from
  #
  # Returns a collection of guides
  getGuides: (ggn) =>
    info = @getDocumentInfo()
    guides = []

    $.each ggn.grids, (index,grid) =>
      positionOffset   = 0
      gridOrientation  = grid.options.orientation.value
      guideOrientation = if gridOrientation == 'horizontal' then 'vertical' else 'horizontal'
      wholePixels      = grid.options.calculation && grid.options.calculation.value == 'pixel'
      fill             = grid.gaps.fill if grid.gaps.fill
      measuredWidth    = if gridOrientation == 'horizontal' then info.width else info.height
      measuredWidth    = grid.options.width.value if grid.options.width
      offset           = if gridOrientation == 'horizontal' then info.offsetX else info.offsetY

      # Calculate and set the value percent gaps. This calculation is based on
      # the document or selection width, less the margin area if it is greater
      # zero.
      if grid.gaps.percents
        $.each grid.gaps.percents, (index,gap) =>
          percentValue = measuredWidth*(gap.value/100)
          Math.floor percentValue if wholePixels
          gap.convertPercent percentValue

      # Subtract arbitrary gap value from non-margin area to get wildcard area,
      # which is used to calculate the size of the wildcards
      arbitrarySum = if grid.gaps.arbitrary then sum grid.gaps.arbitrary, 'value' else 0
      wildcardArea = measuredWidth - arbitrarySum

      if wildcardArea and fill
        # The grid contains a fill, figure out how many times it will fit and generate
        # new gaps for it.
        fillIterations = Math.floor wildcardArea/fill.sum(ggn.variables)
        fillCollection = []
        fillWidth = 0

        for i in [1..fillIterations]
          if fill.isVariable
            fillCollection = fillCollection.concat ggn.variables[fill.id]
            fillWidth += sum ggn.variables[fill.id], 'value'
          else
            newGap = fill.clone()
            newGap.isFill = false
            fillCollection.push newGap
            fillWidth += newGap.value

        wildcardArea -= fillWidth

      if wildcardArea and grid.gaps.wildcards
        # If the grid contains wildcards, figure out and set how wide they are
        wildcardWidth = wildcardArea/grid.gaps.wildcards.length

        if wholePixels
          wildcardWidth = Math.floor wildcardWidth
          remainderPixels = wildcardArea % grid.gaps.wildcards.length

        $.each grid.gaps.wildcards, (index,gap) =>
          gap.value = wildcardWidth

      if remainderPixels
        # If this is a pixel specific grid, whole pixel math usually results in remainder pixels.
        # This decides where amongst the wildcards the remainders should be distributed.
        remainderOffset = 0

        remainderOffset = Math.floor (grid.gaps.wildcards.length - remainderPixels)/2 if grid.options.remainder.value == 'center'
        remainderOffset = grid.gaps.wildcards.length - remainderPixels if grid.options.remainder.value == 'last'

        $.each grid.gaps.wildcards, (index, gap) =>
          gap.value++ if index >= remainderOffset && index < remainderOffset + remainderPixels

      # Figure out where the grid starts
      insertMarker = offset
      if grid.options.width && grid.options.position.value == 'last'
        areaWidth = if gridOrientation == 'horizontal' then info.width else info.height
        insertMarker += areaWidth - grid.options.width.value

      if grid.options.offset
        if grid.options.position.value == 'first'
          insertMarker += grid.options.offset.value
        else if grid.options.position.value == 'last'
          insertMarker -= grid.options.offset.value

      # Expand any fills
      $.each grid.gaps.all, (index,item) =>
        grid.gaps.all = grid.gaps.all.slice(0, index).concat fillCollection, grid.gaps.all.slice(index + 1) if item.isFill

      # Add all the guides
      $.each grid.gaps.all, (index,item) =>
        if item == '|'
          guides.push obj =
            location: insertMarker
            orientation: guideOrientation
        else
          insertMarker += item.value

    # Sort out duplicates
    uniqueGuides =
      horizontal: {}
      vertical: {}

    guides = $.grep guides, (el) =>
      unique = !uniqueGuides[el.orientation][el.location]
      uniqueGuides[el.orientation][el.location] = true
      unique

    guides

# Calculate the sum of an array of values
#
#   array - array to be added together
#   key   - optional key value to be used if array contains objects
#
# Returns a Number
sum = (array, key = null) ->
  total = 0
  $.each array, (index,value) =>
    if key
      total += array[index][key] if array[index][key]
    else
      total += array[index]
  total

