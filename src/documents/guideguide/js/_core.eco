---
write: false
---

class GuideGuide
  siteUrl: 'http://guideguide.me'
  env:     'production'
  activeDocumentInfo:
    ruler: 'px'

  constructor: (@panel) ->
    # Set the application element. This is used because in certain cases
    # GuideGuide is in an iframe.
    @application = parent.$(window.parent.document) || $(document)
    @bridge = parent.window.PanelBridge

    # Set up general GuideGuide UI events.
    @panel.on 'click', '.js-tabbed-page-tab', @onTabClick
    @panel.on 'click', '.js-custom-form .js-make-grid', @onMakeGridFromCusom
    @panel.on 'click', '.js-sets-form .js-make-grid', @onMakeGridFromSet
    @panel.on 'click', '.js-sets-form .js-set-select', @onSelectSet
    @panel.on 'click', '.js-sets-form .js-delete-set', @onDeleteSet
    @panel.on 'click', '.js-grid-form .js-new-set', @onShowGridNewSetForm
    @panel.on 'click', '.js-custom-form .js-new-set', @onShowCustomNewSetForm
    @panel.on 'click', '.js-sets-form .js-new-set', @onShowSetsNewSetForm
    @panel.on 'click', '.js-cancel-set', @onHideNewSetForm
    @panel.on 'click', '.js-grid-form .js-save-set', @onSaveSetFromGrid
    @panel.on 'click', '.js-custom-form .js-save-set', @onSaveSetFromCustom
    @panel.on 'click', '.js-sets-form .js-edit-set', @onEditSet
    @panel.on 'guideguide:exitform', @onExitGridForm
    @panel.on 'guideguide:exitcustom', @onExitCustomForm
    @panel.on 'guideguide:hasUpdate', @onHasUpdate
    @panel.on 'guideguide:upToDate', @onUpToDate
    @panel.on 'focus', '.js-custom-form .js-custom-input', @onFocusCustomForm
    @panel.on 'blur', '.js-custom-form .js-custom-input', @onBlurCustomForm
    @panel.on 'click', '.js-action-bar .js-clear', @onClickClearGuides
    @panel.on 'click', '.js-action-bar .js-top', @onClickTopGuide
    @panel.on 'click', '.js-action-bar .js-bottom', @onClickBottomGuide
    @panel.on 'click', '.js-action-bar .js-left', @onClickLeftGuide
    @panel.on 'click', '.js-action-bar .js-right', @onClickRightGuide
    @panel.on 'click', '.js-action-bar .js-horizontal-midpoint', @onClickHorizontalMidpoint
    @panel.on 'click', '.js-action-bar .js-vertical-midpoint', @onClickVerticalMidpoint
    @panel.on 'mouseover', '.js-grid-form [data-distribute] .js-iconned-input-button', @onMouseOverDistributeIcon
    @panel.on 'mouseout', '.js-grid-form [data-distribute] .js-iconned-input-button', @onMouseOutDistributeIcon
    @panel.on 'click', '.js-grid-form [data-distribute] .js-iconned-input-button', @onClickDistributeIcon
    @panel.on 'focus', '.js-grid-form .js-grid-form-input', @onFocusFormInput
    @panel.on 'blur', '.js-grid-form .js-grid-form-input', @onBlurFormInput
    @panel.on 'click', '.js-grid-form .js-make-grid', @onMakeGridFromForm
    @panel.on 'focus', '.js-set-name', @onFocusSetName
    @panel.on 'click', '.js-toggle-guide-visibility', @onToggleGuides
    @panel.on 'click', '.js-dropdown', @onToggleDropdown
    @panel.on 'click', '.js-dropdown .js-dropdown-item', @onClickDropdownItem
    @panel.on 'click', '.js-import-sets', @onClickImportSets
    @panel.on 'click', '.js-export-sets', @onClickExportSets
    @panel.on 'click', '.js-confirm-submit-data', @onConfirmSubmitData
    @panel.on 'click', '.js-deny-submit-data', @onDenySubmitData
    @panel.on 'click', '.js-check-for-updates', @onClickCheckForUpdates
    @panel.on 'click', '.js-dismiss-alert', @onClickDismissAlert
    @panel.on 'click', '.js-has-update-button', @onClickHasUpdateButton
    @panel.on 'focus', '.js-input input, .js-input textarea', @onInputFocus
    @panel.on 'blur', '.js-input input, .js-input textarea', @onInputBlur
    @panel.on 'input:invalidate', '.js-input', @onInputInvalidate
    @panel.on 'click', '.js-input-shell', @onClickInputBackground

    @panel.find('textarea').autosize();

  # Start GuideGuide
  #
  # Returns nothing
  init: =>
    @bridge.getData @initData

  # When data is received from the application, handle it.
  #
  # Returns nothing.
  initData: (data) =>
    @bridge.log 'Setting up data from application'
    @guideguideData = data

    # Info about this install of GuideGuide
    panelBootstrap =
      id: null
      newSetId: 3
      launchCount: 0
      askedAboutAnonymousData: false
      usage:
        guideActions: 0
        grid: 0
        custom: 0
        set: 0
        top: 0
        bottom: 0
        left: 0
        right: 0
        verticalMidpoint: 0
        horizontalMidpoint: 0
        clear: 0

    # User sets
    setsBootstrap = [
        id: 0
        name:'Outline'
        string: """
        | ~ | (hFl)
        | ~ | (vFl)
        """
      ,
        id: 1
        name:'Two column grid'
        string: """
        | ~ | ~ | (hFl)
        """
      ,
        id: 2
        name:'Three column grid'
        string: """
        | ~ | ~ | ~ | (hFl)
        """
    ]

    # User settings
    settingsBootstrap =
      horizontalRemainder: 'last'
      verticalRemainder:   'last'
      horizontalPosition:  'first'
      verticalPosition:    'first'
      calculation:         'pixel'
      reportAnonymousData: false

    @guideguideData.panel    or= panelBootstrap
    @guideguideData.sets     or= setsBootstrap
    @guideguideData.settings or= settingsBootstrap
    @guideguideData.panel.launchCount++

    @saveGuideGuideData()

    @completeSetup()

  completeSetup: =>
    @refreshSets()
    @bridge.log "Running #{ @guideguideData.application.name } in #{ @guideguideData.application.env } mode"

    @siteUrl = 'http://localhost:5000' if @guideguideData.application.env is 'development'
    @messages = new Messages @guideguideData.application.localization

    @alert 'welcome', ['primary js-confirm-submit-data', 'js-deny-submit-data'], ['ui.yes','ui.no'] if !@guideguideData.panel.askedAboutAnonymousData

    @refreshSettings()
    @localizeUI()
    @submitData()
    @checkForUpdates (data) =>
      if data? and data.hasUpdate
        @panel.trigger 'guideguide:hasUpdate', data

  # Update all of the ui with local messages.
  #
  # Returns nothing.
  localizeUI: =>
    $elements = $('[data-localize]')
    $elements.each (index, el) =>
      $(el).text @messages[$(el).attr('data-localize')]

  # When an input gains focus, outline it's parent and get the most up to date
  # document info.
  #
  # Returns nothing.
  onInputFocus: (event) =>
    $(event.currentTarget).closest('.js-input').addClass 'is-focused'
    $(event.currentTarget).closest('.js-input').removeClass 'is-invalid'
    @bridge.getDocumentInfo (info) =>
      @activeDocumentInfo = info

  # When an input blurs remove its outline.
  #
  # Returns nothing.
  onInputBlur: (event) =>
    $(event.currentTarget).closest('.js-input').removeClass 'is-focused'

  # Outline an invalid input with red.
  #
  # Returns nothing.
  onInputInvalidate: (event) =>
    $(event.currentTarget).addClass 'is-invalid'

  # When the input shell is clicked rather than the input inside, focus the
  # input.
  #
  # Returns nothing.
  onClickInputBackground: (event) =>
    return unless $(event.target).hasClass "js-input-shell"
    $inputs = $(event.currentTarget).find('input')
    $textAreas = $(event.currentTarget).find('textarea')

    $inputs.focus() if $inputs.length
    $textAreas.focus() if $textAreas.length

  # Show the alert and fill its fields
  #
  #   data          - If a string, data is an ID of the message to be added to the alert. If
  #                   an array, the first value is the title to be used, and the second is the message.
  #   buttonClasses - Array of class strings for buttons. A button will be created for each
  #   buttonIDs     - Array of IDs of button messages
  #
  # Returns nothing.
  alert: (data, buttonClasses, buttonNames) =>
    buttonClasses or= ['primary js-dismiss-alert']
    buttonNames   or= ['ui.btnOk']

    title = if typeof data is 'string' then @messages["alertTitle.#{ data }"] else data[0]
    message = if typeof data is 'string' then @messages["alertMessage.#{ data }"] else data[1]

    @panel.find('.js-alert-title').text title
    @panel.find('.js-alert-message').text message
    @panel.find('.js-alert-actions').html ''

    $.each buttonClasses, (i, value) =>
      button = $('.js-button-template').clone().removeClass('js-button-template')
      button.find('a')
      .addClass(buttonClasses[i])
      .text (if buttonNames[i] then @messages[buttonNames[i]] else @messages['ui.btnOk'])
      @panel.find('.js-alert-actions').append button

    @panel.addClass 'has-alert'

  # Handle click on .js-dismiss-alert
  #
  # Returns nothing
  onClickDismissAlert: (event) =>
    event.preventDefault()
    @dismissAlert()

  # Dismiss the alert window and reset its text
  #
  # Returns nothing.
  dismissAlert: =>
    @panel.find('.js-alert-title').text ''
    @panel.find('.js-alert-message').text ''
    @panel.removeClass 'has-alert'

  # Display the correct settings in the Settings tab.
  #
  # Returns nothing.
  refreshSettings: =>
    $dropdowns = $('.js-dropdown')

    $dropdowns.each (index, el) =>
      $dropdown = $ el
      setting   = $dropdown.attr 'data-setting'
      value     = @guideguideData.settings[setting]
      $selected = $dropdown.find("[data-value='#{ value }']")
      $dropdown.find('.js-dropdown-button').text @messages[$selected.attr('data-localize')]

  # Update the panel's color theme
  #
  #   theme - (String) name of the theme to be used
  #
  # Returns nothing.
  updateTheme: (theme) =>
    @panel.attr 'data-theme', theme

  # Behavior for navigating a collection of "pages" via a set of tabs
  #
  # Returns nothing.
  onTabClick: (event) =>
    event.preventDefault()

    exitPage   = @panel.find('.js-tabbed-page-tab.is-selected').attr 'data-page'
    enterPage  = $(event.currentTarget).attr 'data-page'

    return if enterPage == exitPage

    $('#guideguide').trigger "guideguide:exit#{ exitPage }"

    if filter = enterPage
      @selectTab @panel, filter

    $('#guideguide').trigger "guideguide:enter#{ enterPage }"

  # Select the tab that has the given tab-filter. If there is none, select the first tab.
  #
  # $container - (jQuery object) .js-tabbed-pages element
  # name       - (String) content of the data-page attribute. this item will be selected
  #
  # Returns nothing.
  selectTab: ($container, name) =>
    $container.find("[data-page]").removeClass 'is-selected'

    if name
      filter = -> $(this).attr('data-page') is name
      tab = $container.find('.js-tabbed-page-tab').filter filter
      tabBucket = $container.find('.js-tabbed-page').filter filter
    else
      tab = $container.find '.js-tabbed-page-tab:first'
      tabBucket = $container.find '.js-tabbed-page:first'

    # Select tab and bucket
    tab.addClass 'is-selected'
    tabBucket.addClass 'is-selected'

  # Toggle dropdown visibilty
  #
  # Returns nothing.
  onToggleDropdown: (event) =>
    event.preventDefault()

    if $(event.target).hasClass 'js-dropdown-backdrop'
      $('.js-dropdown').removeClass('is-active')
    else
      $dropdown = $(event.currentTarget)
      $dropdown.toggleClass 'is-active'
      $list = $dropdown.find('.js-dropdown-list')
      visibleBottom = $('.js-settings-list').scrollTop() + $('.js-settings-list').outerHeight()
      listBottom = $dropdown.position().top + $list.position().top + $list.outerHeight() + 3

      if listBottom > visibleBottom
        offset = listBottom - visibleBottom
        $('.js-settings-list').scrollTop $('.js-settings-list').scrollTop() + offset

    @panel.toggleClass 'has-dropdown'

  # Update settings and dropdown button when a dropdown item is clicked.
  #
  # Returns nothing.
  onClickDropdownItem: (event) =>
    event.preventDefault()
    $item     = $ event.currentTarget
    $dropdown = $item.closest '.js-dropdown'
    setting   = $dropdown.attr 'data-setting'
    value     = $item.attr 'data-value'
    value     = true if value is "true"
    value     = false if value is "false"

    $dropdown.find('.js-dropdown-button').text @messages[$item.attr('data-localize')]
    @guideguideData.settings[setting] = value
    @saveGuideGuideData()

  # Toggle guide visibility.
  #
  # Returns nothing.
  onToggleGuides: (event) =>
    event.preventDefault()
    @bridge.log "Toggle guides"
    @bridge.toggleGuides()

  # Save GuideGuide's data, including usage data, user preferences, and sets
  #
  # Returns nothing.
  saveGuideGuideData: =>
    @bridge.setData @guideguideData

  # Increment a usage counter of a given property.
  #
  #   property - usage property to increment
  #
  # Returns nothing.
  recordUsage: (property) =>
    if @guideguideData.panel.usage[property]?
      @guideguideData.panel.usage[property]++
      @guideguideData.panel.usage.guideActions++ if property isnt 'clear'
      @saveGuideGuideData()

  # When the user grants data collection permission, update the settings and
  # dismiss the alert.
  #
  # Returns nothing.
  onConfirmSubmitData: (event) =>
    event.preventDefault()
    @guideguideData.settings.reportAnonymousData = true
    @guideguideData.panel.askedAboutAnonymousData = true
    @saveGuideGuideData()
    @refreshSettings()
    @dismissAlert()

  # When the user denies data collection, dismiss the alert. Data submission
  # is disabled by default, so we don't need to change it.
  #
  # Returns nothing.
  onDenySubmitData: (event) =>
    event.preventDefault()
    @guideguideData.panel.askedAboutAnonymousData = true
    @saveGuideGuideData()
    @dismissAlert()

  # Draw a guide at the top of the document/selection
  #
  # Return nothing.
  onClickTopGuide: (event) =>
    @bridge.log 'Top guide'
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      @getGuidesFromGGN new GGN("| ~ (h#{ 'p' if @guideguideData.settings.calculation == 'pixel' })"), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
    @recordUsage 'top'

  # Draw a guide at the bottom of the document/selection
  #
  # Return nothing.
  onClickBottomGuide: (event) =>
    @bridge.log 'Bottom guide'
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      @getGuidesFromGGN new GGN("~ | (h#{ 'p' if @guideguideData.settings.calculation == 'pixel' })"), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
    @recordUsage 'bottom'

  # Draw a guide to the left of the document/selection
  #
  # Return nothing.
  onClickLeftGuide: (event) =>
    @bridge.log 'Left guide'
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      @getGuidesFromGGN new GGN("| ~ (v#{ 'p' if @guideguideData.settings.calculation == 'pixel' })"), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
    @recordUsage 'left'

  # Draw a guide to the right of the document/selection
  #
  # Return nothing.
  onClickRightGuide: (event) =>
    @bridge.log 'Bottom guide'
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      @getGuidesFromGGN new GGN("~ | (v#{ 'p' if @guideguideData.settings.calculation == 'pixel' })"), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
    @recordUsage 'right'

  # Draw a guide at the horizontal midpoint of the document/selection
  #
  # Return nothing.
  onClickHorizontalMidpoint: (event) =>
    @bridge.log 'Horizontal midpoint'
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      @getGuidesFromGGN new GGN("~ | ~ (h#{ 'p' if @guideguideData.settings.calculation == 'pixel' })"), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
    @recordUsage 'horizontalMidpoint'

  # Draw a guide at the vertical midpoint of the document/selection
  #
  # Return nothing.
  onClickVerticalMidpoint: (event) =>
    @bridge.log 'Vertical midpoint'
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      @getGuidesFromGGN new GGN("~ | ~ (v#{ 'p' if @guideguideData.settings.calculation == 'pixel' })"), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
    @recordUsage 'verticalMidpoint'

  # Handle clicks on the clear guides button.
  #
  # Returns nothing.
  onClickClearGuides: (event) =>
    event.preventDefault()
    @clearGuides()
    @recordUsage 'clear'

  # Removes guides from the document based on document or selection
  #
  #   guides - collection of all existing guides before clearing
  #
  # Returns nothing.
  clearGuides: =>
    @bridge.log "Clear guides"
    @bridge.getDocumentInfo (info) =>
      if info.isSelection
        bounds =
          top:    info.offsetY
          left:   info.offsetX
          bottom: info.offsetY + info.height
          right:  info.offsetX + info.width
        @resetGuides()
        @bridge.addGuides @consolidateGuides [info.existingGuides], bounds, true
      else
        @resetGuides()

  # Removes all guides from the document
  #
  # Returns nothing.
  resetGuides: =>
    @bridge.log 'Resetting guides'
    @bridge.resetGuides()

  # Highlight all field icons of similar type
  #
  # Returns nothing.
  onMouseOverDistributeIcon: (event) =>
    $form   = $(event.currentTarget).closest '.js-grid-form'
    type    = $(event.currentTarget).closest('[data-distribute]').attr 'data-distribute'
    $fields = @filteredList $form.find('.js-grid-form-iconned-input'), type

    $fields.addClass 'distribute-highlight'

  # Remove highlight from field icons
  #
  # Returns nothing.
  onMouseOutDistributeIcon: (event) =>
    @panel.find('.distribute-highlight').removeClass('distribute-highlight')

  # When one of the input icons is clicked, change all fields of the same type
  # to that value
  #
  # Returns nothing.
  onClickDistributeIcon: (event) =>
    event.preventDefault()
    $form  = $(event.currentTarget).closest '.js-grid-form'
    $input = $(event.currentTarget).closest '.js-grid-form-iconned-input'
    $field = $input.find('.js-grid-form-input')
    @formatField $field
    value   = $field.val()
    type    = $input.attr 'data-distribute'
    $fields = @filteredList $form.find('.js-grid-form-iconned-input'), type
    $fields.find('.js-grid-form-input').val value

  # When a field is unfocused, validate its contents
  #
  # Returns noting.
  onBlurFormInput: (event) =>
    $input = $(event.currentTarget)
    if $input.val()
      int = false

      if $input.attr 'data-integer'
        val = Math.round parseFloat $input.val()
        $input.val val if val
        int = true

      if !@isValid $input.val(), int
        $input.trigger 'input:invalidate'
      else
        @formatField $input
        $form  = $input.closest '.js-grid-form'
        @stringifyFormData @getFormData($form), (string) =>
          @panel.find('.js-custom-input').val(string).trigger('autosize.resize')

  # Clear any error reporting text and reset the Custom forms's validation
  #
  # Returns nothing.
  onFocusCustomForm: (event) =>
    $input = $(event.currentTarget)
    $input.val $input.val().replace(/[\{\}]|\[.*?\]|^#.*?$/gm, '').replace(/\s+$/g,'')

  # Validate the contents of the Custom form
  #
  # Returns nothing.
  onBlurCustomForm: (event) =>
    $input = $(event.currentTarget)
    if string = $input.val().replace /^\s+|\s+$/g, ''
      ggn = new GGN $input.val()
      $input.trigger 'input:invalidate' if !ggn.isValid
      $input.val ggn.toString()
      $input.trigger('autosize.resize')

  # Select a set in the sets list when it is clicked
  #
  # Returns nothing.
  onSelectSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget)
    $set.closest('.js-sets-form').find('.is-selected').removeClass('is-selected')
    $set.closest('.js-set').addClass('is-selected')

  # Delete a set and update the set list.
  #
  # Returns nothing.
  onDeleteSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget).closest '.js-set'
    id = $set.attr 'data-id'

    @guideguideData.sets = $.grep @guideguideData.sets, (set) -> parseInt(set.id) != parseInt(id)

    @saveGuideGuideData()
    @refreshSets()

  # Handle clicks on the check for updates button
  #
  # Returns nothing.
  onClickCheckForUpdates: (event) =>
    event.preventDefault()
    @checkForUpdates (data) =>
      @bridge.log data
      if data? and data.hasUpdate
        @panel.trigger 'guideguide:hasUpdate', data
        $('.js-has-update-button').click()
      else
        @panel.trigger 'guideguide:upToDate'

  # Check the GuideGuide server to see if there are updates available.
  #
  # Returns nothing.
  checkForUpdates: (callback) =>
    return unless @guideguideData.application.checkForUpdates
    @bridge.log 'Checking for updates'

    $.ajax
      type: 'GET'
      url: "#{ @siteUrl }/panel/#{ @guideguideData.application.id }"
      data:
        version: @guideguideData.application.guideguideVersion || '0.0.0'
        i18n: @guideguideData.application.localization
      success: (data) =>
        callback(data)
      error: (error) =>
        @bridge.log error

  onClickHasUpdateButton: (event) =>
    event.preventDefault()
    title = $(event.currentTarget).attr 'data-title'
    message = $(event.currentTarget).attr 'data-message'
    @alert [title, message], ['primary js-dismiss-alert'], ['ui.btnOk']

  # When this install of GuideGuide is out of date, alert the user.
  #
  # Returns nothing.
  onHasUpdate: (event, data) =>
    @panel.addClass 'has-update'
    button = @panel.find '.js-has-update-button'
    button.attr 'data-title', data.title
    button.attr 'data-message', data.message

  # When this install is up to date, tell the user if they initiated the update check
  #
  # Returns nothing
  onUpToDate: (event) =>
    @alert 'upToDate', ['primary js-dismiss-alert'], ['ui.btnOk']

  # Submit anonymous usage data to the GuideGuide servers.
  #
  #   dev - if true, data is sent to a local update server
  #
  # Returns nothing.
  submitData: =>
    return unless @guideguideData.settings.reportAnonymousData and @guideguideData.application.submitAnonymousData
    @bridge.log 'Submitting anonymous data'

    data =
      usage: @guideguideData.panel.usage

    if @guideguideData.panel.id?
      data._id          = @guideguideData.panel.id
    else
      data.version      = @guideguideData.application.guideguideVersion
      data.appID        = @guideguideData.application.id
      data.appName      = @guideguideData.application.name
      data.AppVersion   = @guideguideData.application.version
      data.os           = @guideguideData.application.os
      data.localization = @guideguideData.application.localization

    $.ajax
      type: 'POST'
      url: "#{ @siteUrl }/install"
      data: data
      success: (data) =>
        @bridge.log 'Anonymous data submitted successfully'
        if typeof data is 'object' and data._id
          @guideguideData.panel.id = data._id
          @saveGuideGuideData()

  # Get the version of this install of GuideGuide.
  #
  # Returns a semantic version string http://semver.org/
  getVersion: =>
    '0.0.0'

  # Determine the version of the app in which GuideGuide is running.
  #
  # Returns a semantic version string http://semver.org/
  getAppVersion: =>
    '0.0.0'

  # Determine the operating system in which GuideGuide is running
  #
  # Returns a String.
  getOS: =>
    'Unknown OS'

  # Add sets to GuideGuide from an external source.
  #
  # Returns nothing.
  onClickImportSets: (event) =>
    event.preventDefault()
    @bridge.log 'Import sets'

  # Export GuideGuide's sets to an external source.
  #
  # Returns nothing.
  onClickExportSets: (event) =>
    event.preventDefault()
    @bridge.log 'Export sets'

  # When exiting the Custom form, clear the new set form.
  #
  # Returns nothing
  onExitGridForm: =>
    @hideNewSetForm()

  # When exiting the Custom form, clear it.
  #
  # Returns nothing
  onExitCustomForm: =>
    @hideNewSetForm()

  # Open Custom form with data from the set to be edited
  #
  # Returns nothing.
  onEditSet: (event) =>
    event.preventDefault()
    $('#guideguide').find('.js-custom-tab').click()

    $set = $(event.currentTarget).closest('.js-set')
    id = $set.attr('data-id')

    set = $.grep @guideguideData.sets, (set) -> parseInt(set.id) == parseInt(id)

    $form = @panel.find('.js-custom-form')
    $form.find('.js-set-name').val(set[0].name)
    $form.find('.js-set-id').val(set[0].id)

    @showCustomSetForm(set[0].string)

  # Save a set from the Custom form.
  #
  # Returns nothing.
  onSaveSetFromCustom: (event) =>
    event.preventDefault()
    $form      = @panel.find('.js-custom-form')
    string     = $('.js-custom-input').val().replace /^\s+|\s+$/g, ''
    name       = $form.find('.js-set-name').val()
    executable = $form.find('.js-input.is-invalid').length == 0 and string.length > 0 and name.length > 0
    @bridge.log 'foo: ', $form


    if executable
      obj =
        id: $form.find('.js-set-id').val()
        name: name
        ggn: string

      if !$('#guideguide').find('.js-set-id').val()
        @createNewSet(obj)
      else
        @updateSet(obj)

      @panel.find('.js-sets-tab').click()
    else
      $('.js-set-name').trigger 'input:invalidate' if name.length == 0
      $('.js-custom-input').trigger 'input:invalidate' if string.length == 0

  # Fire save set event and pass it the contents of the grid form
  #
  # Returns nothing.
  onSaveSetFromGrid: (event) =>
    event.preventDefault()
    $form      = @panel.find('.js-grid-form')
    data       = @getFormData $form
    @stringifyFormData data, (string) =>
      executable = $form.find('.js-input.is-invalid').length == 0 and string

      if executable
        @bridge.group 'New set from form'
        @bridge.log string
        @bridge.groupEnd()
        obj =
          name: data.name
          ggn: string

        @createNewSet(obj)
        @panel.find('.js-sets-tab').click()

  # Create a grid from the Grid form
  #
  # Returns Nothing.
  onMakeGridFromForm: (event) =>
    event.preventDefault()
    $form  = $(event.currentTarget).closest '.js-grid-form'
    @stringifyFormData @getFormData($form), (string) =>

      return unless $form.find('.js-input.is-invalid').length == 0 and string

      @bridge.getDocumentInfo (info) =>
        return unless info

        @bridge.group 'Add guides from grid form'
        @bridge.log string
        ggn = new GGN(string)
        @bridge.log ggn
        @getGuidesFromGGN new GGN(string), info, (guides) =>
          @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
        @bridge.groupEnd()
        @recordUsage 'grid'

  # Create a grid from the Custom form
  #
  # Returns nothing.
  onMakeGridFromCusom: (event) =>
    event.preventDefault()
    $form  = @panel.find('.js-custom-form')
    string = @panel.find('.js-custom-input').val().replace(/^\s+|\s+$/g, '')

    return unless $form.find('.js-input.is-invalid').length == 0 and string

    @bridge.getDocumentInfo (info) =>
      return unless info

      @bridge.log 'Custom Grid'
      @bridge.log string
      @getGuidesFromGGN new GGN(string), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
      @recordUsage 'custom'

  # Create a grid from a set
  #
  # Returns nothing.
  onMakeGridFromSet: (event) =>
    event.preventDefault()
    $set = $('.js-set-list').find('.is-selected').first()

    return unless $set.length

    @bridge.getDocumentInfo (info) =>
      return unless info

      @bridge.log 'Grid from set'
      data = $.grep @guideguideData.sets, (set) -> parseInt(set.id) == parseInt($set.attr 'data-id')
      @bridge.log data
      @getGuidesFromGGN new GGN(data[0].string), info, (guides) =>
        @bridge.addGuides @consolidateGuides([guides, info.existingGuides])
      @recordUsage 'set'

  createNewSet: (data) =>
    newSet =
      id: @guideguideData.panel.newSetId
      name: data.name
      string: data.ggn

    @guideguideData.panel.newSetId++
    @guideguideData.sets.push newSet
    @saveGuideGuideData()
    @refreshSets()

  updateSet: (data) =>
    set = $.grep @guideguideData.sets, (set) -> parseInt(set.id) == parseInt(data.id)

    set[0].name = data.name
    set[0].string = data.ggn

    @saveGuideGuideData()
    @refreshSets()

  # Remove any sets in the markup and update the list with a new set items for
  # each set in the list.
  #
  # Returns nothing.
  refreshSets: =>
    @bridge.log 'Refreshing sets'
    $list = @panel.find('.js-set-list')
    $list.find('.js-set').remove()
    $.each @guideguideData.sets, (index,set) =>
      item = $('.js-set-item-template').clone(true).removeClass('js-set-item-template')
      item.find('.js-set-item-name').html set.name
      item.attr 'data-id', set.id
      $list.append item

  # Handle clicks on the new set button
  #
  # Returns nothing
  onShowCustomNewSetForm: (event) =>
    event.preventDefault()
    @showCustomSetForm()

  onShowSetsNewSetForm: (event) =>
    event.preventDefault()

    @bridge.getDocumentInfo (info) =>
      xString = ''
      yString = ''
      prevHorizontal = if info.isSelection then info.offsetY else 0
      prevVertical = if info.isSelection then info.offsetX else 0
      guides = info.existingGuides

      if info.isSelection
        bounds =
          top:    info.offsetY
          left:   info.offsetX
          bottom: info.offsetY + info.height
          right:  info.offsetX + info.width
        guides = @consolidateGuides [guides, info.existingGuides], bounds

      guides.sort (a,b) =>
        a.location - b.location

      $.each guides, (index, guide) =>
        if guide.orientation == 'vertical'
          xString = "#{ xString }#{ guide.location - prevVertical }px | "
          prevVertical = guide.location
        if guide.orientation == 'horizontal'
          yString = "#{ yString }#{ guide.location - prevHorizontal }px | "
          prevHorizontal = guide.location

      xString = "#{ xString }(v#{ 'p' if @guideguideData.settings.calculation == 'pixel' })" if xString != ''
      yString = "#{ yString }(h#{ 'p' if @guideguideData.settings.calculation == 'pixel' })" if yString != ''

      string = ''
      string += xString
      string += '\n' if xString
      string += yString
      string += '\n' if yString
      string += '\n# ' + @messages['ggn.stringFromExistingGuides'] if xString or yString

      @showCustomSetForm string

  # On the Grid page, display and focus new set name field, swap in save set
  # and cancel set buttons, hide make grid and new set buttons.
  #
  # Returns nothing.
  showCustomSetForm: (prefill = '') =>
    @panel.find('.js-custom-tab').click() if @panel.find('.js-sets-tab.is-selected').length
    @panel.addClass('is-showing-new-set-form')
    @panel.find('.js-custom-input').val prefill
    @panel.find('.js-custom-form').find('.js-set-name').focus()

  # On the Custom page, display and focus new set name field, swap in save set
  # and cancel set buttons, hide make grid and new set buttons.
  #
  # Returns nothing.
  onShowGridNewSetForm: (event) =>
    event.preventDefault()
    @panel.addClass('is-showing-new-set-form')
    @panel.find('.js-grid-form').find('.js-set-name').focus()

  # On both forms, Hide new set name, swap out save set and cancel set buttons, show make
  # grid and new set buttons
  #
  # Returns nothing.
  onHideNewSetForm: (event) =>
    event.preventDefault()
    @hideNewSetForm()

  # Hide the new set form and clear any data if it exists.
  #
  # Returns nothing.
  hideNewSetForm: =>
    @panel.find('.js-grid-form').find('.js-set-name').val('')
    @panel.find('.js-grid-form').find('.js-set-id').val('')
    @panel.removeClass('is-showing-new-set-form')

  # Turn a GuideGuide object into a collection of guides.
  #
  #   ggn - GuideGuide Object to pull guides from
  #
  # Returns a collection of guides
  getGuidesFromGGN: (ggn, info, callback) =>
    guides = []

    $.each ggn.grids, (index,grid) =>
      positionOffset   = 0
      guideOrientation = grid.options.orientation.value
      wholePixels      = grid.options.calculation && grid.options.calculation.value == 'pixel'
      fill             = grid.gaps.fill if grid.gaps.fill
      measuredWidth    = if guideOrientation == 'horizontal' then info.height else info.width
      measuredWidth    = grid.options.width.value if grid.options.width
      offset           = if guideOrientation == 'horizontal' then info.offsetY else info.offsetX

      # Calculate and set the value percent gaps. This calculation is based on
      # the document or selection width, less the margin area if it is greater
      # zero.
      if grid.gaps.percents
        $.each grid.gaps.percents, (index,gap) =>
          percentValue = measuredWidth*(gap.value/100)
          Math.floor percentValue if wholePixels
          gap.convertPercent percentValue

      # Subtract arbitrary gap value from non-margin area to get wildcard area,
      # which is used to calculate the size of the wildcards
      arbitrarySum = if grid.gaps.arbitrary then @sum grid.gaps.arbitrary, 'value' else 0
      wildcardArea = measuredWidth - arbitrarySum

      if wildcardArea and fill
        # The grid contains a fill, figure out how many times it will fit and generate
        # new gaps for it.
        fillIterations = Math.floor wildcardArea/fill.sum(ggn.variables)
        fillCollection = []
        fillWidth = 0

        for i in [1..fillIterations]
          if fill.isVariable
            fillCollection = fillCollection.concat ggn.variables[fill.id]
            fillWidth += @sum ggn.variables[fill.id], 'value'
          else
            newGap = fill.clone()
            newGap.isFill = false
            fillCollection.push newGap
            fillWidth += newGap.value

        wildcardArea -= fillWidth

      if wildcardArea and grid.gaps.wildcards
        # If the grid contains wildcards, figure out and set how wide they are
        wildcardWidth = wildcardArea/grid.gaps.wildcards.length

        if wholePixels
          wildcardWidth = Math.floor wildcardWidth
          remainderPixels = wildcardArea % grid.gaps.wildcards.length

        $.each grid.gaps.wildcards, (index,gap) =>
          gap.value = wildcardWidth

      if remainderPixels
        # If this is a pixel specific grid, whole pixel math usually results in remainder pixels.
        # This decides where amongst the wildcards the remainders should be distributed.
        remainderOffset = 0

        remainderOffset = Math.floor (grid.gaps.wildcards.length - remainderPixels)/2 if grid.options.remainder.value == 'center'
        remainderOffset = grid.gaps.wildcards.length - remainderPixels if grid.options.remainder.value == 'last'

        $.each grid.gaps.wildcards, (index, gap) =>
          gap.value++ if index >= remainderOffset && index < remainderOffset + remainderPixels

      # Figure out where the grid starts
      insertMarker = offset
      if grid.options.width && grid.options.position.value == 'last'
        areaWidth = if guideOrientation == 'horizontal' then info.height else info.width
        insertMarker += areaWidth - grid.options.width.value

      if grid.options.offset
        if grid.options.position.value == 'first'
          insertMarker += grid.options.offset.value
        else if grid.options.position.value == 'last'
          insertMarker -= grid.options.offset.value

      # Expand any fills
      $.each grid.gaps.all, (index,item) =>
        grid.gaps.all = grid.gaps.all.slice(0, index).concat fillCollection, grid.gaps.all.slice(index + 1) if item.isFill

      # Add all the guides
      $.each grid.gaps.all, (index,item) =>
        if item == '|'
          guides.push obj =
            location: insertMarker
            orientation: guideOrientation
        else
          insertMarker += item.value

    callback(guides)

  # Create a collection of unique guides from multiple guide arrrays
  #
  #   guideArrays - (Array) collection of guide arrays
  #   bounds      - (Object) boundaries within which guides must fall to be included
  #   invert      - (Boolean) If true, include only guides outside the bounds
  #
  # Returns an array of guides
  consolidateGuides: (guideArrays, bounds = null, invert = false) =>
    uniqueGuides =
      horizontal: {}
      vertical: {}

    guides = []

    for array in guideArrays
      guides = guides.concat array

    if bounds
      guides = $.grep guides, (el) =>
        unique = !uniqueGuides[el.orientation][el.location]
        if unique
          uniqueGuides[el.orientation][el.location] = true
          if el.orientation == 'vertical'
            if invert
              return el.location < bounds.left or el.location > bounds.right
            else
              return el.location >= bounds.left and el.location <= bounds.right
          if el.orientation == 'horizontal'
            if invert
              return el.location < bounds.top or el.location > bounds.bottom
            else
              return el.location >= bounds.top and el.location <= bounds.bottom
        else
          return false
    else
      guides = $.grep guides, (el) =>
        unique = !uniqueGuides[el.orientation][el.location]
        uniqueGuides[el.orientation][el.location] = true
        unique

    guides

  stringifyFormData: (data, callback) ->
    @bridge.getDocumentInfo (info) =>
      string = ''
      # Variables
      if data.countColumn or data.widthColumn
        string += '$h =|'
        string += if data.widthColumn then data.widthColumn else '~'
        string += '|'
        string += data.gutterColumn if data.gutterColumn
        string += '\n'

      if data.countRow or data.widthRow
        string += '$v =|'
        string += if data.widthRow then data.widthRow else '~'
        string += '|'
        string += data.gutterRow if data.gutterRow
        string += '\n'

      string += '\n' if data.countColumn or data.widthColumn or data.countRow or data.widthRow

      if data.marginLeft or data.marginRight or data.countColumn or data.widthColumn
        # Grids
        string += '|' + data.marginLeft.replace(/\s/g,'').split(',').join('|') + '|' if data.marginLeft
        if data.countColumn or data.widthColumn
          string += '|$h*'
          string += data.countColumn - 1 if data.countColumn
          string += '|' + data.widthColumn if (data.widthColumn and data.countColumn) or (data.widthColumn and data.gutterColumn)
          string += '|~' if !data.widthColumn
          string += '|'
        if data.marginRight
          string += '~' if (!data.countColumn and !data.widthColumn) or (data.countColumn and data.widthColumn)
          string += '|' + data.marginRight.replace(/\s/g,'').split(',').join('|') + '|'
        string += '( vF'
        string += 'f' if @guideguideData.settings.horizontalRemainder == 'first'
        string += 'c' if @guideguideData.settings.horizontalRemainder == 'center'
        string += 'l' if @guideguideData.settings.horizontalRemainder == 'last'
        string += 'p' if @guideguideData.settings.calculation == 'pixel'
        string += ' )\n'

      if data.marginTop or data.marginBottom or data.countRow or data.widthRow
        # Grids
        string += '|' + data.marginTop.replace(/\s/g,'').split(',').join('|') + '|' if data.marginTop
        if data.countRow or data.widthRow
          string += '|$v*'
          string += data.countRow - 1 if data.countRow
          string += '|' + data.widthRow if (data.widthRow and data.countRow) or (data.widthRow and data.gutterRow)
          string += '|~' if !data.widthRow
          string += '|'
        if data.marginBottom
          string += '~' if (!data.countRow and !data.widthRow) or (data.countRow and data.widthRow)
          string += '|' + data.marginBottom.replace(/\s/g,'').split(',').join('|') + '|'
        string += '( hF'
        string += 'f' if @guideguideData.settings.horizontalRemainder == 'first'
        string += 'c' if @guideguideData.settings.horizontalRemainder == 'center'
        string += 'l' if @guideguideData.settings.horizontalRemainder == 'last'
        string += 'p' if @guideguideData.settings.calculation == 'pixel'
        string += ' )'

      # Rather than fiddle with spaces and duplicate pipes in the string calculation,
      # just do a second pass on the string to clean everything up.
      callback string.replace(/\|+/g,'|').replace(/\|/g, ' | ').replace(/^[^\S\n]+|[^\S\n]+$/mg,'')

  # Calculate the sum of an array of values
  #
  #   array - array to be added together
  #   key   - optional key value to be used if array contains objects
  #
  # Returns a Number
  sum: (array, key = null) ->
    total = 0
    $.each array, (index,value) =>
      if key
        total += array[index][key] if array[index][key]
      else
        total += array[index]
    total

  # Reformat a unit string to match conventions
  #
  #   $field - input to format
  #
  # Returns a String
  formatField: ($field) ->
    int = if $field.attr 'data-integer' then true else false
    $field.val $.map $field.val().split(','), (unit) ->
      new Unit(unit,int).toString()
    .join(', ')

  # Sort a list of form fields and return ones that match a filter
  #
  #    $list - list of objects to be filtered
  #    type  - type of form field to return
  #
  # Returns an Array of jquery objects
  filteredList: ($list,type) ->
    filter  = -> $(this).attr('data-distribute') is type
    $fields = $list.filter filter

  # Collect data from the grid form.
  #
  #   $form - jQuery object of the form to be used
  #
  # Returns an Object
  getFormData: ($form) ->
    obj =
      name: $('.js-grid-form .js-set-name').val()

    $fields = $form.find '.js-grid-form-input'
    $fields.each (index,element) ->
      key = $(element).attr 'data-type'
      obj[key] = $(element).val()
    obj

  # Determine whether the value in the form is valid
  #
  #   string - string to be validated
  #
  # Returns a Boolean
  isValid: (string, integerOnly = false) ->
    units = string.split ','
    units = units.filter (unit) =>
      u = new Unit(unit,integerOnly)
      !u.isValid

    units.length == 0
