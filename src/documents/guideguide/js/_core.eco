---
write: false
---

class GuideGuide
  siteUrl: 'http://guideguide.me'
  env:     'production'
  activeDocumentInfo:
    ruler: 'px'

  constructor: (@panel) ->
    # Set the application element. This is used because in certain cases
    # GuideGuide is in an iframe.
    @application = parent.$(window.parent.document) || $(document)
    @bridge = parent.window.PanelBridge

    @panel.on 'click', '.js-custom-form .js-make-grid', @onMakeGridFromCusom
    @panel.on 'click', '.js-sets-form .js-make-grid', @onMakeGridFromSet
    @panel.on 'click', '.js-sets-form .js-set-select', @onSelectSet
    @panel.on 'click', '.js-sets-form .js-delete-set', @onDeleteSet
    @panel.on 'click', '.js-grid-form .js-new-set', @onShowGridNewSetForm
    @panel.on 'click', '.js-custom-form .js-new-set', @onShowCustomNewSetForm
    @panel.on 'click', '.js-sets-form .js-new-set', @onShowSetsNewSetForm
    @panel.on 'click', '.js-cancel-set', @onHideNewSetForm
    @panel.on 'click', '.js-grid-form .js-save-set', @onSaveSetFromGrid
    @panel.on 'click', '.js-custom-form .js-save-set', @onSaveSetFromCustom
    @panel.on 'click', '.js-sets-form .js-edit-set', @onEditSet
    @panel.on 'guideguide:hasUpdate', @onHasUpdate
    @panel.on 'focus', '.js-custom-form .js-custom-input', @onFocusCustomForm
    @panel.on 'blur', '.js-custom-form .js-custom-input', @onBlurCustomForm
    @panel.on 'click', '.js-action-bar .js-clear', @onClickClearGuides
    @panel.on 'click', '.js-action-bar .js-top', @onClickTopGuide
    @panel.on 'click', '.js-action-bar .js-bottom', @onClickBottomGuide
    @panel.on 'click', '.js-action-bar .js-left', @onClickLeftGuide
    @panel.on 'click', '.js-action-bar .js-right', @onClickRightGuide
    @panel.on 'click', '.js-action-bar .js-horizontal-midpoint', @onClickHorizontalMidpoint
    @panel.on 'click', '.js-action-bar .js-vertical-midpoint', @onClickVerticalMidpoint
    @panel.on 'mouseover', '.js-grid-form [data-distribute] .js-iconned-input-button', @onMouseOverDistributeIcon
    @panel.on 'mouseout', '.js-grid-form [data-distribute] .js-iconned-input-button', @onMouseOutDistributeIcon
    @panel.on 'click', '.js-grid-form [data-distribute] .js-iconned-input-button', @onClickDistributeIcon
    @panel.on 'focus', '.js-grid-form .js-grid-form-input', @onFocusFormInput
    @panel.on 'blur', '.js-grid-form .js-grid-form-input', @onBlurFormInput
    @panel.on 'click', '.js-grid-form .js-make-grid', @onMakeGridFromForm
    @panel.on 'focus', '.js-set-name', @onFocusSetName
    @panel.on 'click', '.js-dropdown', @onToggleDropdown
    @panel.on 'click', '.js-dropdown .js-dropdown-item', @onClickDropdownItem
    @panel.on 'click', '.js-help-target', @onClickHelpTarget
    @panel.on 'click', '.js-checkbox', @onClickCheckbox
    @panel.on 'click', '.js-import-sets', @onShowImporter
    @panel.on 'click', '.js-import', @onClickImportSets
    @panel.on 'click', '.js-cancel-import', @onClickCancelImport
    @panel.on 'click', '.js-export-sets', @onClickExportSets
    @panel.on 'click', '.js-link', @onClickLink
    @panel.on 'click', '.js-confirm-submit-data', @onConfirmSubmitData
    @panel.on 'click', '.js-deny-submit-data', @onDenySubmitData
    @panel.on 'click', '.js-check-for-updates', @onClickCheckForUpdates
    @panel.on 'click', '.js-show-logs', @onClickShowLogs
    @panel.on 'click', '.js-dismiss-alert', @onClickDismissAlert
    @panel.on 'click', '.js-donate', @onClickDonate
    @panel.on 'click', '.js-has-update-button', @onClickHasUpdateButton
    @panel.on 'focus', '.js-input input, .js-input textarea', @onInputFocus
    @panel.on 'blur', '.js-input input, .js-input textarea', @onInputBlur
    @panel.on 'input:invalidate', '.js-input', @onInputInvalidate
    @panel.on 'click', '.js-input-shell', @onClickInputBackground

  # When an input gains focus, outline it's parent and get the most up to date
  # document info.
  #
  # Returns nothing.
  onInputFocus: (event) =>
    $(event.currentTarget).closest('.js-input').addClass 'is-focused'
    $(event.currentTarget).closest('.js-input').removeClass 'is-invalid'
    @bridge.getDocumentInfo (info) =>
      @activeDocumentInfo = info

  # When an input blurs remove its outline.
  #
  # Returns nothing.
  onInputBlur: (event) =>
    $(event.currentTarget).closest('.js-input').removeClass 'is-focused'

  # Outline an invalid input with red.
  #
  # Returns nothing.
  onInputInvalidate: (event) =>
    $(event.currentTarget).addClass 'is-invalid'

  # When the input shell is clicked rather than the input inside, focus the
  # input.
  #
  # Returns nothing.
  onClickInputBackground: (event) =>
    return unless $(event.target).hasClass "js-input-shell"
    $inputs = $(event.currentTarget).find('input')
    $textAreas = $(event.currentTarget).find('textarea')

    $inputs.focus() if $inputs.length
    $textAreas.focus() if $textAreas.length

  # Hide and reveal help text.
  #
  # Returns nothing
  onClickHelpTarget: (event) =>
    event.preventDefault()
    $(event.currentTarget).closest('.js-help').toggleClass "is-helping"

  # Toggle checkboxes
  #
  # Returns nothing
  onClickCheckbox: (event) =>
    event.preventDefault()
    $checkbox = $(event.currentTarget)
    $checkbox.toggleClass 'checked'

    $form  = $checkbox.closest '.js-grid-form'
    @stringifyFormData @getFormData($form), (string) =>
      @updateCustomField string


  onClickDonate: =>
    event.preventDefault()
    @bridge.openURL "http://guideguide.me/donate"

  # Display the correct settings in the Settings tab.
  #
  # Returns nothing.
  refreshSettings: =>
    $dropdowns = $('.js-dropdown')

    $dropdowns.each (index, el) =>
      $dropdown = $ el
      setting   = $dropdown.attr 'data-setting'
      value     = @guideguideData.settings[setting]
      $selected = $dropdown.find("[data-value='#{ value }']")
      $dropdown.find('.js-dropdown-button').text @messages[$selected.attr('data-localize')]()

  # Toggle dropdown visibilty
  #
  # Returns nothing.
  onToggleDropdown: (event) =>
    event.preventDefault()

    if $(event.target).hasClass 'js-dropdown-backdrop'
      $('.js-dropdown').removeClass('is-active')
    else
      $dropdown = $(event.currentTarget)
      $dropdown.toggleClass 'is-active'
      $list = $dropdown.find('.js-dropdown-list')
      visibleBottom = $('.js-settings-list').scrollTop() + $('.js-settings-list').outerHeight()
      listBottom = $dropdown.position().top + $list.position().top + $list.outerHeight() + 3

      if listBottom > visibleBottom
        offset = listBottom - visibleBottom
        $('.js-settings-list').scrollTop $('.js-settings-list').scrollTop() + offset

    @panel.toggleClass 'has-dropdown'

  # Update settings and dropdown button when a dropdown item is clicked.
  #
  # Returns nothing.
  onClickDropdownItem: (event) =>
    event.preventDefault()
    $item     = $ event.currentTarget
    $dropdown = $item.closest '.js-dropdown'
    setting   = $dropdown.attr 'data-setting'
    value     = $item.attr 'data-value'
    value     = true if value is "true"
    value     = false if value is "false"

    $dropdown.find('.js-dropdown-button').text @messages[$item.attr('data-localize')]()
    @guideguideData.settings[setting] = value
    @saveGuideGuideData()

  # Increment a usage counter of a given property.
  #
  #   property - usage property to increment
  #   count    - number of guides being added
  #
  # Returns nothing.
  recordUsage: (property, count) =>
    @guideguideData.panel.usage.lifetime += count
    if @guideguideData.panel.usage[property]?
      @guideguideData.panel.usage[property]++
      @guideguideData.panel.usage.guideActions++ if property isnt 'clear'
      @saveGuideGuideData()

    if @guideguideData.panel.usage.guideActions == 30 and @guideguideData.application.env != 'demo'
      title   = @messages.alertTitleDonate()
      message = @messages.alertMessageDonate()
      @alert [title, message], ['primary js-donate', 'js-dismiss-alert'], [@messages.uiDonate(), @messages.uiNiceNo()]

  # When the user denies data collection, dismiss the alert. Data submission
  # is disabled by default, so we don't need to change it.
  #
  # Returns nothing.
  onDenySubmitData: (event) =>
    event.preventDefault()
    @guideguideData.panel.askedAboutAnonymousData = true
    @saveGuideGuideData()
    @dismissAlert()

  # Draw a guide at the top of the document/selection
  #
  # Return nothing.
  onClickTopGuide: (event) =>
    event.preventDefault()
    @addGuidesfromGGN "| ~ (h#{ @getCalculationType() })", 'top'

  # Draw a guide at the bottom of the document/selection
  #
  # Return nothing.
  onClickBottomGuide: (event) =>
    event.preventDefault()
    @addGuidesfromGGN "~ | (h#{ @getCalculationType() })", 'bottom'

  # Draw a guide to the left of the document/selection
  #
  # Return nothing.
  onClickLeftGuide: (event) =>
    event.preventDefault()
    @addGuidesfromGGN "| ~ (v#{ @getCalculationType() })", 'left'

  # Draw a guide to the right of the document/selection
  #
  # Return nothing.
  onClickRightGuide: (event) =>
    event.preventDefault()
    @addGuidesfromGGN "~ | (v#{ @getCalculationType() })", 'right'

  # Draw a guide at the horizontal midpoint of the document/selection
  #
  # Return nothing.
  onClickHorizontalMidpoint: (event) =>
    @bridge.log "Clicked Horizontal Midpoint"
    event.preventDefault()
    @addGuidesfromGGN "~ | ~ (h#{ @getCalculationType() })", 'horizontalMidpoint'

  # Draw a guide at the vertical midpoint of the document/selection
  #
  # Return nothing.
  onClickVerticalMidpoint: (event) =>
    @bridge.log "Clicked Vertical Midpoint"
    event.preventDefault()
    @addGuidesfromGGN "~ | ~ (v#{ @getCalculationType() })", 'verticalMidpoint'

  # Get the option value that corresponds to the calculation type of the app
  #
  # Returns a String
  getCalculationType: =>
    if @guideguideData.settings.calculation == 'pixel' then 'p' else ''

  # Handle clicks on the clear guides button.
  #
  # Returns nothing.
  onClickClearGuides: (event) =>
    event.preventDefault()
    @bridge.getDocumentInfo (info) =>
      return unless info.hasOpenDocuments

      @clearGuides()
      @recordUsage 'clear'

  # Removes guides from the document based on document or selection
  #
  #   guides - collection of all existing guides before clearing
  #
  # Returns nothing.
  clearGuides: =>
    @bridge.log "Clear guides"
    @bridge.getDocumentInfo (info) =>
      if info.isSelection
        bounds =
          top:    info.offsetY
          left:   info.offsetX
          bottom: info.offsetY + info.height
          right:  info.offsetX + info.width
        @resetGuides()
        @bridge.addGuides @consolidateGuides [info.existingGuides], bounds, true
      else
        @resetGuides()

  # Removes all guides from the document
  #
  # Returns nothing.
  resetGuides: =>
    @bridge.log 'Resetting guides'
    @bridge.resetGuides()

  addGuidesfromGGN: (ggn, source) =>
    @bridge.getDocumentInfo (info) =>
      return unless info and info.hasOpenDocuments
      guides = []

      @getGuidesFromGGN new GGN(ggn), info, (g) =>
        guides = @consolidateGuides([g, info.existingGuides])

        @bridge.log "Add guides from #{ source }"
        @recordUsage source, guides.length
        @bridge.resetGuides()
        @bridge.addGuides guides

  # Updates the text in the custom field and resizes it
  #
  # Returns nothing
  updateCustomField: (text) =>
    @panel.find('.js-custom-input').val(text).trigger('autosize.resize')

  # Highlight all field icons of similar type
  #
  # Returns nothing.
  onMouseOverDistributeIcon: (event) =>
    $form   = $(event.currentTarget).closest '.js-grid-form'
    type    = $(event.currentTarget).closest('[data-distribute]').attr 'data-distribute'
    $fields = @filteredList $form.find('.js-grid-form-iconned-input'), type

    $fields.addClass 'distribute-highlight'

  # Remove highlight from field icons
  #
  # Returns nothing.
  onMouseOutDistributeIcon: (event) =>
    @panel.find('.distribute-highlight').removeClass('distribute-highlight')

  # When one of the input icons is clicked, change all fields of the same type
  # to that value
  #
  # Returns nothing.
  onClickDistributeIcon: (event) =>
    event.preventDefault()
    $form  = $(event.currentTarget).closest '.js-grid-form'
    $input = $(event.currentTarget).closest '.js-grid-form-iconned-input'
    $field = $input.find('.js-grid-form-input')
    @formatField $field
    value   = $field.val()
    type    = $input.attr 'data-distribute'
    $fields = @filteredList $form.find('.js-grid-form-iconned-input'), type
    $fields.find('.js-grid-form-input').val value

    @stringifyFormData @getFormData($form), (string) =>
      @updateCustomField string

  # When a field is unfocused, validate its contents
  #
  # Returns noting.
  onBlurFormInput: (event) =>
    $input = $(event.currentTarget)

    int = false

    if $input.attr 'data-integer'
      val = Math.round parseFloat $input.val()
      $input.val val if val
      int = true

    if !@isValid $input.val(), int
      $input.trigger 'input:invalidate'
    else
      @formatField $input
      $form  = $input.closest '.js-grid-form'
      @stringifyFormData @getFormData($form), (string) =>
        @updateCustomField string

  # Clear any error reporting text and reset the Custom forms's validation
  #
  # Returns nothing.
  onFocusCustomForm: (event) =>
    $input = $(event.currentTarget)
    $input.val $input.val().replace(/[\{\}]|\[.*?\]|^#.*?$/gm, '').replace(/\s+$/g,'')

  # Validate the contents of the Custom form
  #
  # Returns nothing.
  onBlurCustomForm: (event) =>
    $input = $(event.currentTarget)
    if string = $input.val().replace /^\s+|\s+$/g, ''
      ggn = new GGN $input.val()
      $input.trigger 'input:invalidate' if !ggn.isValid
      $input.val ggn.toString()
      $input.trigger('autosize.resize')

  # Generate a set ID based on a hash of the GGN. This will allow us to detect
  # duplicates easier.
  #
  #   set - set object used as a seed for the ID hash
  #
  # returns a String
  # generateSetID: (set) =>
  #   CryptoJS.SHA1("#{ set.name }#{ set.string }").toString()

  # Select a set in the sets list when it is clicked
  #
  # Returns nothing.
  onSelectSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget)
    $set.closest('.js-sets-form').find('.is-selected').removeClass('is-selected')
    $set.closest('.js-set').addClass('is-selected')

  # Delete a set and update the set list.
  #
  # Returns nothing.
  onDeleteSet: (event) =>
    event.preventDefault()
    $set = $(event.currentTarget).closest '.js-set'
    id = $set.attr 'data-id'
    group = $set.attr 'data-group'

    delete @guideguideData.sets[group].sets[id]

    @saveGuideGuideData()
    @refreshSets()

  # Show the debug logs.
  #
  # Returns nothing.
  onClickShowLogs: =>
    event.preventDefault()
    @bridge.showLogs() if @bridge.showLogs

  # Handle clicks on the check for updates button
  #
  # Returns nothing.
  onClickCheckForUpdates: (event) =>
    event.preventDefault()
    return unless @guideguideData.application.checkForUpdates
    @panel.addClass 'is-loading'
    @checkForUpdates (data) =>
      @bridge.log data
      if data?
        if data.hasUpdate
          @panel.trigger 'guideguide:hasUpdate', data
          $('.js-has-update-button').click()
        else
          title   = @messages.alertTitleUpToDate()
          message = @messages.alertMessageUpToDate()
          @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]
      else
        title   = @messages.alertTitleUpdateError()
        message = @messages.alertMessageUpdateError()
        @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]

  onClickHasUpdateButton: (event) =>
    event.preventDefault()
    title = $(event.currentTarget).attr 'data-title'
    message = $(event.currentTarget).attr 'data-message'
    @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]

  # Import sets from a gist url
  #
  #   gistID - id of the GitHub gist to import
  #
  # Returns nothing
  importSetsFromGist: (gistID) =>
    @panel.addClass 'is-loading'
    $.ajax
      url: "https://api.github.com/gists/#{ gistID }"
      type: 'GET'
      complete: (data) =>
        @panel.removeClass 'is-loading'
      success: (data) =>
        if data.files["sets.json"] and sets = JSON.parse data.files["sets.json"].content
          @importSets sets
          @refreshSets()
          @selectTab @panel, 'sets'
          title   = @messages.alertTitleImportSuccess()
          message = @messages.alertMessageImportSuccess()
          @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]
        else
          title   = @messages.alertTitleImportGistNoSets()
          message = @messages.alertMessageImportGistNoSets()
          @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]
      error: (data) =>
        title   = @messages.alertTitleImportGistError()
        message = @messages.alertMessageImportGistError()
        @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]

  # Import an array of sets
  #
  #   sets - array of sets to import
  #
  # Returns nothing
  importSets: (sets) =>
    @bridge.log "Sets imported"
    @panel.removeClass 'is-showing-importer'
    console.log sets

    for key, group of sets
      @guideguideData.sets[key] ||=
        name: group.name
        sets: []

      g = @guideguideData.sets[key]

      for key, set of group.sets
        g.sets[set.id] = set if !g.sets[set.id]?

    @saveGuideGuideData()

  # Show the set importer
  #
  # Returns nothing.
  onShowImporter: (event) =>
    event.preventDefault()
    return if @guideguideData.application.env == 'demo'
    @panel.addClass 'is-showing-importer'
    @panel.find('.js-import-input').val ''

  # Add sets to GuideGuide from an external source.
  #
  # Returns nothing.
  onClickImportSets: (event) =>
    event.preventDefault()
    return if @guideguideData.application.env == 'demo'

    data = $(".js-import-input").val()

    # Is it a gist?
    if data.indexOf("gist.github.com") > 0
      id = data.substring data.lastIndexOf('/') + 1
      @importSetsFromGist id
    else
      title   = @messages.alertTitleImportNotGist()
      message = @messages.alertMessageImportNotGist()
      @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]

  # Dismiss the importer
  #
  # Returns nothing
  onClickCancelImport: (event) =>
    event.preventDefault()
    @panel.removeClass 'is-showing-importer'

  # Export GuideGuide's sets to an external source.
  #
  # Returns nothing.
  onClickExportSets: (event) =>
    event.preventDefault()
    return if @guideguideData.application.env == 'demo'

    @bridge.log 'Export sets'
    data =
      description: @messages.helpGistExport()
      public: false
      files:
        "sets.json":
          content: JSON.stringify @guideguideData.sets

    @panel.addClass 'is-loading'
    $.ajax
      url: 'https://api.github.com/gists'
      type: 'POST'
      data: JSON.stringify data
      complete: (data) =>
        @panel.removeClass 'is-loading'
      success: (data) =>
        title   = @messages.alertTitleExportSuccess()
        message = "#{ @messages.alertMessageExportSuccess() } <div><strong><a class='js-link button export-button' href='#{ data.html_url }'>#{ @messages.uiOpenInBrowser() }</a></strong></div>"

        @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]
      error: (data) =>
        title   = @messages.alertTitleExportError()
        message = @messages.alertMessagesExportError()
        @alert [title, message], ['primary js-dismiss-alert'], [@messages.uiOk()]

  # Open a exported sets url
  #
  # Returns nothing
  onClickLink: (event) =>
    event.preventDefault()
    url = $(event.currentTarget).attr 'href'
    @bridge.openURL url

  # Open Custom form with data from the set to be edited
  #
  # Returns nothing.
  onEditSet: (event) =>
    event.preventDefault()
    $('#guideguide').find('.js-custom-tab').click()

    $set  = $(event.currentTarget).closest('.js-set')
    id    = $set.attr('data-id')
    group = $set.attr('data-group')

    set = @guideguideData.sets[group].sets[id]

    $form = @panel.find('.js-custom-form')
    $form.find('.js-set-name').val(set.name)
    $form.find('.js-set-id').val(set.id)

    @showCustomSetForm(set.string)

  # Save a set from the Custom form.
  #
  # Returns nothing.
  onSaveSetFromCustom: (event) =>
    event.preventDefault()
    $form      = @panel.find('.js-custom-form')
    string     = $('.js-custom-input').val().replace /^\s+|\s+$/g, ''
    name       = $form.find('.js-set-name').val()
    executable = $form.find('.js-input.is-invalid').length == 0 and string.length > 0 and name.length > 0

    if executable
      obj =
        oldID: $form.find('.js-set-id').val()
        id: @generateSetID
          name: name
          string: string
        group: "Default"
        name: name
        string: string

      if !$('#guideguide').find('.js-set-id').val()
        @createNewSet(obj)
      else
        @updateSet(obj)

      @panel.find('.js-sets-tab').click()
    else
      $('.js-set-name').trigger 'input:invalidate' if name.length == 0
      $('.js-custom-input').trigger 'input:invalidate' if string.length == 0

  # Fire save set event and pass it the contents of the grid form
  #
  # Returns nothing.
  onSaveSetFromGrid: (event) =>
    event.preventDefault()
    $form      = @panel.find('.js-grid-form')
    data       = @getFormData $form
    @stringifyFormData data, (string) =>
      executable = $form.find('.js-input.is-invalid').length == 0 and string

      if executable
        @bridge.log 'New set from form'
        @bridge.log string
        obj =
          name: data.name
          ggn: string

        @createNewSet(obj)
        @panel.find('.js-sets-tab').click()

  # Create a grid from the Grid form
  #
  # Returns Nothing.
  onMakeGridFromForm: (event) =>
    event.preventDefault()
    $form  = $(event.currentTarget).closest '.js-grid-form'
    @stringifyFormData @getFormData($form), (string) =>
      return unless $form.find('.js-input.is-invalid').length == 0 and string
      @addGuidesfromGGN string, 'grid'

  # Create a grid from the Custom form
  #
  # Returns nothing.
  onMakeGridFromCusom: (event) =>
    event.preventDefault()
    $form  = @panel.find('.js-custom-form')
    string = @panel.find('.js-custom-input').val().replace(/^\s+|\s+$/g, '')
    return unless $form.find('.js-input.is-invalid').length == 0 and string
    @addGuidesfromGGN string, 'custom'

  # Create a grid from a set
  #
  # Returns nothing.
  onMakeGridFromSet: (event) =>
    event.preventDefault()
    $set = $('.js-set-list').find('.is-selected').first()
    return unless $set.length
    id    = $set.attr 'data-id'
    group = $set.attr 'data-group'
    data  = @guideguideData.sets[group].sets[id]
    @addGuidesfromGGN data.string, 'set'

  createNewSet: (data) =>
    newSet =
      id: @generateSetID data
      name: data.name
      string: data.string

    @guideguideData.sets["Default"].sets[newSet.id] = newSet
    @saveGuideGuideData()
    @refreshSets()

  updateSet: (data) =>
    delete @guideguideData.sets[data.group].sets[data.oldID]
    newSet =
      name: data.name
      string: data.string

    newSet.id = @generateSetID newSet

    @guideguideData.sets[data.group].sets[data.id] = newSet

    @saveGuideGuideData()
    @refreshSets()

  # Remove any sets in the markup and update the list with a new set items for
  # each set in the list.
  #
  # Returns nothing.
  refreshSets: =>
    @bridge.log 'Refreshing sets'
    $list = @panel.find('.js-set-list')
    $list.find('.js-set').remove()
    $.each @guideguideData.sets["Default"].sets, (index,set) =>
      item = $('.js-set-item-template').clone(true).removeClass('js-set-item-template')
      item.find('.js-set-item-name').html set.name
      item.attr 'data-group', "Default"
      item.attr 'data-id', set.id
      $list.append item

  # Handle clicks on the new set button
  #
  # Returns nothing
  onShowCustomNewSetForm: (event) =>
    event.preventDefault()
    @showCustomSetForm()

  onShowSetsNewSetForm: (event) =>
    event.preventDefault()

    @bridge.getDocumentInfo (info) =>
      xString = ''
      yString = ''
      string  = ''

      prevHorizontal = if info.isSelection then info.offsetY else 0
      prevVertical = if info.isSelection then info.offsetX else 0
      guides = info.existingGuides

      if info.isSelection
        bounds =
          top:    info.offsetY
          left:   info.offsetX
          bottom: info.offsetY + info.height
          right:  info.offsetX + info.width
        guides = @consolidateGuides [guides, info.existingGuides], bounds

      if guides
        guides.sort (a,b) =>
          a.location - b.location

        $.each guides, (index, guide) =>
          if guide.orientation == 'vertical'
            xString = "#{ xString }#{ guide.location - prevVertical }px | "
            prevVertical = guide.location
          if guide.orientation == 'horizontal'
            yString = "#{ yString }#{ guide.location - prevHorizontal }px | "
            prevHorizontal = guide.location

        xString = "#{ xString }(v#{ 'p' if @guideguideData.settings.calculation == 'pixel' })" if xString != ''
        yString = "#{ yString }(h#{ 'p' if @guideguideData.settings.calculation == 'pixel' })" if yString != ''

        string += xString
        string += '\n' if xString
        string += yString
        string += '\n' if yString
        string += '\n# ' + @messages.ggnStringFromExistingGuides() if xString or yString

      @showCustomSetForm string

  # On the Grid page, display and focus new set name field, swap in save set
  # and cancel set buttons, hide make grid and new set buttons.
  #
  # Returns nothing.
  showCustomSetForm: (prefill = '') =>
    @panel.find('.js-custom-tab').click() if @panel.find('.js-sets-tab.is-selected').length
    @panel.addClass('is-showing-new-set-form')
    @updateCustomField prefill if prefill
    @panel.find('.js-custom-form').find('.js-set-name').focus()

  # On the Custom page, display and focus new set name field, swap in save set
  # and cancel set buttons, hide make grid and new set buttons.
  #
  # Returns nothing.
  onShowGridNewSetForm: (event) =>
    event.preventDefault()
    @panel.addClass('is-showing-new-set-form')
    @panel.find('.js-grid-form').find('.js-set-name').focus()

  # On both forms, Hide new set name, swap out save set and cancel set buttons, show make
  # grid and new set buttons
  #
  # Returns nothing.
  onHideNewSetForm: (event) =>
    event.preventDefault()
    @hideNewSetForm()

  # Turn a GuideGuide object into a collection of guides.
  #
  #   ggn - GuideGuide Object to pull guides from
  #
  # Returns a collection of guides
  getGuidesFromGGN: (ggn, info, callback) =>
    guides = []

    $.each ggn.grids, (index,grid) =>
      guideOrientation = grid.options.orientation.value
      wholePixels      = grid.options.calculation && grid.options.calculation.value == 'pixel'
      fill             = grid.gaps.fill if grid.gaps.fill
      measuredWidth    = if guideOrientation == 'horizontal' then info.height else info.width
      measuredWidth    = grid.options.width.value if grid.options.width
      offset           = if guideOrientation == 'horizontal' then info.offsetY else info.offsetX

      # Calculate and set the value percent gaps. This calculation is based on
      # the document or selection width, less the margin area if it is greater
      # zero.
      if grid.gaps.percents
        $.each grid.gaps.percents, (index,gap) =>
          percentValue = measuredWidth*(gap.value/100)
          Math.floor percentValue if wholePixels
          gap.convertPercent percentValue

      # Subtract arbitrary gap value from non-margin area to get wildcard area,
      # which is used to calculate the size of the wildcards
      arbitrarySum = if grid.gaps.arbitrary then @sum grid.gaps.arbitrary, 'value' else 0
      wildcardArea = measuredWidth - arbitrarySum

      if wildcardArea and fill
        # The grid contains a fill, figure out how many times it will fit and generate
        # new gaps for it.
        fillIterations = Math.floor wildcardArea/fill.sum(ggn.variables)
        fillCollection = []
        fillWidth = 0

        for i in [1..fillIterations]
          if fill.isVariable
            fillCollection = fillCollection.concat ggn.variables[fill.id].all
            fillWidth += @sum ggn.variables[fill.id].all, 'value'
          else
            newGap = fill.clone()
            newGap.isFill = false
            fillCollection.push newGap
            fillWidth += newGap.value

        wildcardArea -= fillWidth

      if wildcardArea and grid.gaps.wildcards
        # If the grid contains wildcards, figure out and set how wide they are
        wildcardWidth = wildcardArea/grid.gaps.wildcards.length

        if wholePixels
          wildcardWidth = Math.floor wildcardWidth
          remainderPixels = wildcardArea % grid.gaps.wildcards.length

        $.each grid.gaps.wildcards, (index,gap) =>
          gap.value = wildcardWidth

      if remainderPixels
        # If this is a pixel specific grid, whole pixel math usually results in remainder pixels.
        # This decides where amongst the wildcards the remainders should be distributed.
        remainderOffset = 0

        remainderOffset = Math.floor (grid.gaps.wildcards.length - remainderPixels)/2 if grid.options.remainder.value == 'center'
        remainderOffset = grid.gaps.wildcards.length - remainderPixels if grid.options.remainder.value == 'last'

        $.each grid.gaps.wildcards, (index, gap) =>
          gap.value++ if index >= remainderOffset && index < remainderOffset + remainderPixels

      # Figure out where the grid starts
      insertMarker = if grid.options.offset then grid.options.offset.value else offset

      # Expand any fills
      $.each grid.gaps.all, (index,item) =>
        grid.gaps.all = grid.gaps.all.slice(0, index).concat fillCollection, grid.gaps.all.slice(index + 1) if item.isFill

      # Add all the guides
      $.each grid.gaps.all, (index,item) =>
        if item == '|'
          guides.push obj =
            location: insertMarker
            orientation: guideOrientation
        else
          insertMarker += item.value

    callback(guides)

  # Create a collection of unique guides from multiple guide arrrays
  #
  #   guideArrays - (Array) collection of guide arrays
  #   bounds      - (Object) boundaries within which guides must fall to be included
  #   invert      - (Boolean) If true, include only guides outside the bounds
  #
  # Returns an array of guides
  consolidateGuides: (guideArrays, bounds = null, invert = false) =>
    uniqueGuides =
      horizontal: {}
      vertical: {}

    guides = []

    for array in guideArrays
      guides = guides.concat array

    if bounds
      guides = $.grep guides, (el) =>
        unique = !uniqueGuides[el.orientation][el.location]
        if unique
          uniqueGuides[el.orientation][el.location] = true
          if el.orientation == 'vertical'
            if invert
              return el.location < bounds.left or el.location > bounds.right
            else
              return el.location >= bounds.left and el.location <= bounds.right
          if el.orientation == 'horizontal'
            if invert
              return el.location < bounds.top or el.location > bounds.bottom
            else
              return el.location >= bounds.top and el.location <= bounds.bottom
        else
          return false
    else
      guides = $.grep guides, (el) =>
        unique = !uniqueGuides[el.orientation][el.location]
        uniqueGuides[el.orientation][el.location] = true
        unique
    guides


  # Convert a section of the grid from (rows or columns) to a string
  #
  #  data   - data from the form
  #  prefix - prefix
  #
  # Returns a string
  stringifyFormGrid: (data) ->
    data.count      = parseInt data.count
    firstMargString = ''
    varString       = ''
    gridString      = ''
    lastMargString  = ''
    optionsString   = ''

    # Set up the margins, if they exist
    firstMargString = '|' + data.firstMargin.replace(/\s/g,'').split(',').join('|') + '|' if data.firstMargin
    lastMargString  = '|' + data.lastMargin.replace(/\s/g,'').split(',').join('|') + '|' if data.lastMargin

    # Set up the columns and gutters variables, if they exist
    if data.count or data.width
      column = if data.width then data.width else '~'
      if data.columnMidpoint
        unit   = new Unit data.width if data.width
        column = if data.width then "#{ unit.value/2 }#{ unit.type }|#{ unit.value/2 }#{ unit.type }" else "~|~"

      varString += "$#{ data.orientation }=|#{ column }|"


      if data.gutter and data.count != 1
        gutter = if data.gutter then data.gutter else '~'
        if data.gutterMidpoint
          unit   = new Unit data.gutter if data.gutter
          gutter = if data.gutter then "#{ unit.value/2 }#{ unit.type }|#{ unit.value/2 }#{ unit.type }" else "~|~"

        varString  = "$#{ data.orientation }=|#{ column }|#{ gutter }|"
        varString += "\n$#{ data.orientation }C=|#{ column }|" if data.count

    # Set up the grid string
    if data.count or data.width
      gridString += "|$#{ data.orientation }"
      gridString += "*" if data.count != 1
      gridString += data.count - 1 if data.count > 1 and data.gutter
      gridString += data.count if data.count > 1 and !data.gutter
      gridString += "|"
      gridString += "|$#{ data.orientation }#{ if data.gutter then 'C' else '' }|" if data.count > 1 and data.gutter

    if (!data.count and !data.width) and (data.firstMargin or data.lastMargin)
      gridString += "|~|"

    if data.firstMargin or data.lastMargin or data.count or data.width
      # Set up the options
      optionsString += "("
      optionsString += data.orientation.charAt(0).toLowerCase()
      optionsString += data.remainder.charAt(0).toLowerCase()
      optionsString += "p" if @guideguideData.settings.calculation == "pixel"
      optionsString += ")"

    leftBuffer = rightBuffer = ""
    if data.width
      leftBuffer = "~" if data.position == "last" or data.position == "center"
      rightBuffer = "~" if data.position == "first" or data.position == "center"

    # Bring it all together
    """
    #{ varString }
    #{ firstMargString }#{ leftBuffer }#{ gridString }#{ rightBuffer }#{ lastMargString }#{ optionsString }\n
    """

  stringifyFormData: (data, callback) ->
    @bridge.getDocumentInfo (info) =>
      string = ''
      # Variables

      string += @stringifyFormGrid
        count:          data.countColumn
        width:          data.widthColumn
        gutter:         data.gutterColumn
        firstMargin:    data.marginLeft
        lastMargin:     data.marginRight
        columnMidpoint: data.midpointColumn || false
        gutterMidpoint: data.midpointColumnGutter || false
        orientation:    'v'
        position:       @guideguideData.settings.verticalPosition
        remainder:      @guideguideData.settings.verticalRemainder

      string += @stringifyFormGrid
        count:          data.countRow
        width:          data.widthRow
        gutter:         data.gutterRow
        firstMargin:    data.marginTop
        lastMargin:     data.marginBottom
        columnMidpoint: data.midpointRow || false
        gutterMidpoint: data.midpointRowGutter || false
        orientation:    'h'
        position:       @guideguideData.settings.horizontalPosition
        remainder:      @guideguideData.settings.horizontalRemainder

      string = $.trim string
      callback if string then new GGN(string).toString() else ""

  # Calculate the sum of an array of values
  #
  #   array - array to be added together
  #   key   - optional key value to be used if array contains objects
  #
  # Returns a Number
  sum: (array, key = null) ->
    total = 0
    $.each array, (index,value) =>
      if key
        total += array[index][key] if array[index][key]
      else
        total += array[index]
    total

  # Reformat a unit string to match conventions
  #
  #   $field - input to format
  #
  # Returns a String
  formatField: ($field) ->
    int = if $field.attr 'data-integer' then true else false
    $field.val $.map $field.val().split(','), (unit) ->
      new Unit(unit,int).toString()
    .join(', ')

  # Sort a list of form fields and return ones that match a filter
  #
  #    $list - list of objects to be filtered
  #    type  - type of form field to return
  #
  # Returns an Array of jquery objects
  filteredList: ($list,type) ->
    filter  = -> $(this).attr('data-distribute') is type
    $fields = $list.filter filter

  # Collect data from the grid form.
  #
  #   $form - jQuery object of the form to be used
  #
  # Returns an Object
  getFormData: ($form) ->
    obj =
      name: $('.js-grid-form .js-set-name').val()

    $fields = $form.find '.js-grid-form-input'
    $fields.each (index, element) ->
      key = $(element).attr 'data-type'
      obj[key] = $(element).val()

    $checkboxes = $form.find '.js-checkbox'
    $checkboxes.each (index, element) ->
      key = $(element).attr 'data-type'
      obj[key] = true if $(element).hasClass 'checked'
    obj

  # Determine whether the value in the form is valid
  #
  #   string - string to be validated
  #
  # Returns a Boolean
  isValid: (string, integerOnly = false) ->
    return true if string == ""
    units = string.split ','
    units = units.filter (unit) =>
      u = new Unit(unit,integerOnly)
      !u.isValid

    units.length == 0
